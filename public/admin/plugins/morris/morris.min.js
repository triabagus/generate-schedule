(function() {
    function p(t, i) {
        return function() {
            return t.apply(i, arguments)
        }
    }

    function t(t, i) {
        function e() {
            this.constructor = t
        }
        for (var o in i) d.call(i, o) && (t[o] = i[o]);
        return e.prototype = i.prototype, t.prototype = new e, t.__super__ = i.prototype, t
    }
    var m, M, i, e, o, s, n, r, h, a, l, u = [].slice,
        d = {}.hasOwnProperty,
        c = [].indexOf || function(t) {
            for (var i = 0, e = this.length; i < e; i++)
                if (i in this && this[i] === t) return i;
            return -1
        };

    function f(t, i, e, o, s, n, r, h, a, l) {
        this.cx = t, this.cy = i, this.inner = e, this.outer = o, this.color = r, this.backgroundColor = h, this.index = a, this.raphael = l, this.deselect = p(this.deselect, this), this.select = p(this.select, this), this.sin_p0 = Math.sin(s), this.cos_p0 = Math.cos(s), this.sin_p1 = Math.sin(n), this.cos_p1 = Math.cos(n), this.is_long = n - s > Math.PI ? 1 : 0, this.path = this.calcSegment(this.inner + 3, this.inner + this.outer - 5), this.selectedPath = this.calcSegment(this.inner + 3, this.inner + this.outer), this.hilight = this.calcArc(this.inner)
    }

    function g(t) {
        this.resizeHandler = p(this.resizeHandler, this), this.select = p(this.select, this), this.click = p(this.click, this);
        var i = this;
        if (!(this instanceof M.Donut)) return new M.Donut(t);
        if (this.options = m.extend({}, this.defaults, t), this.el = "string" == typeof t.element ? m(document.getElementById(t.element)) : m(t.element), null === this.el || 0 === this.el.length) throw new Error("Graph placeholder not found.");
        void 0 !== t.data && 0 !== t.data.length && (this.raphael = new Raphael(this.el[0]), this.options.resize && m(window).bind("resize", function() {
            return null != i.timeoutId && window.clearTimeout(i.timeoutId), i.timeoutId = window.setTimeout(i.resizeHandler, 100)
        }), this.setData(t.data))
    }

    function y(t) {
        return this.onHoverOut = p(this.onHoverOut, this), this.onHoverMove = p(this.onHoverMove, this), this.onGridClick = p(this.onGridClick, this), this instanceof M.Bar ? void y.__super__.constructor.call(this, m.extend({}, t, {
            parseTime: !1
        })) : new M.Bar(t)
    }

    function v(t) {
        var i;
        return this instanceof M.Area ? (i = m.extend({}, h, t), this.cumulative = !i.behaveLikeLine, "auto" === i.fillOpacity && (i.fillOpacity = i.behaveLikeLine ? .8 : 1), void v.__super__.constructor.call(this, i)) : new M.Area(t)
    }

    function x(t) {
        return this.hilight = p(this.hilight, this), this.onHoverOut = p(this.onHoverOut, this), this.onHoverMove = p(this.onHoverMove, this), this.onGridClick = p(this.onGridClick, this), this instanceof M.Line ? void x.__super__.constructor.call(this, t) : new M.Line(t)
    }

    function w(t) {
        null == t && (t = {}), this.options = m.extend({}, M.Hover.defaults, t), this.el = m("<div class='" + this.options.class + "'></div>"), this.el.hide(), this.options.parent.append(this.el)
    }

    function b(t) {
        this.resizeHandler = p(this.resizeHandler, this);
        var n = this;
        if (this.el = "string" == typeof t.element ? m(document.getElementById(t.element)) : m(t.element), null == this.el || 0 === this.el.length) throw new Error("Graph container element not found");
        "static" === this.el.css("position") && this.el.css("position", "relative"), this.options = m.extend({}, this.gridDefaults, this.defaults || {}, t), "string" == typeof this.options.units && (this.options.postUnits = t.units), this.raphael = new Raphael(this.el[0]), this.elementWidth = null, this.elementHeight = null, this.dirty = !1, this.selectFrom = null, this.init && this.init(), this.setData(this.options.data), this.el.bind("mousemove", function(t) {
            var i, e, o, s;
            return e = n.el.offset(), s = t.pageX - e.left, n.selectFrom ? (i = n.data[n.hitTest(Math.min(s, n.selectFrom))]._x, o = n.data[n.hitTest(Math.max(s, n.selectFrom))]._x - i, n.selectionRect.attr({
                x: i,
                width: o
            })) : n.fire("hovermove", s, t.pageY - e.top)
        }), this.el.bind("mouseleave", function() {
            return n.selectFrom && (n.selectionRect.hide(), n.selectFrom = null), n.fire("hoverout")
        }), this.el.bind("touchstart touchmove touchend", function(t) {
            var i, e;
            return e = t.originalEvent.touches[0] || t.originalEvent.changedTouches[0], i = n.el.offset(), n.fire("hovermove", e.pageX - i.left, e.pageY - i.top)
        }), this.el.bind("click", function(t) {
            var i;
            return i = n.el.offset(), n.fire("gridclick", t.pageX - i.left, t.pageY - i.top)
        }), this.options.rangeSelect && (this.selectionRect = this.raphael.rect(0, 0, 0, this.el.innerHeight()).attr({
            fill: this.options.rangeSelectColor,
            stroke: !1
        }).toBack().hide(), this.el.bind("mousedown", function(t) {
            var i;
            return i = n.el.offset(), n.startRange(t.pageX - i.left)
        }), this.el.bind("mouseup", function(t) {
            var i;
            return i = n.el.offset(), n.endRange(t.pageX - i.left), n.fire("hovermove", t.pageX - i.left, t.pageY - i.top)
        })), this.options.resize && m(window).bind("resize", function() {
            return null != n.timeoutId && window.clearTimeout(n.timeoutId), n.timeoutId = window.setTimeout(n.resizeHandler, 100)
        }), this.el.css("-webkit-tap-highlight-color", "rgba(0,0,0,0)"), this.postInit && this.postInit()
    }

    function F() {}
    M = window.Morris = {}, m = jQuery, M.EventEmitter = (F.prototype.on = function(t, i) {
        return null == this.handlers && (this.handlers = {}), null == this.handlers[t] && (this.handlers[t] = []), this.handlers[t].push(i), this
    }, F.prototype.fire = function() {
        var t, i, e, o, s, n, r;
        if (e = arguments[0], t = 2 <= arguments.length ? u.call(arguments, 1) : [], null != this.handlers && null != this.handlers[e]) {
            for (r = [], o = 0, s = (n = this.handlers[e]).length; o < s; o++) i = n[o], r.push(i.apply(null, t));
            return r
        }
    }, F), M.commas = function(t) {
        var i, e, o, s;
        return null != t ? (o = t < 0 ? "-" : "", i = Math.abs(t), o += (e = Math.floor(i).toFixed(0)).replace(/(?=(?:\d{3})+$)(?!^)/g, ","), (s = i.toString()).length > e.length && (o += s.slice(e.length)), o) : "-"
    }, M.pad2 = function(t) {
        return (t < 10 ? "0" : "") + t
    }, M.Grid = (l = M.EventEmitter, t(b, l), b.prototype.gridDefaults = {
        dateFormat: null,
        axes: !0,
        grid: !0,
        gridLineColor: "#aaa",
        gridStrokeWidth: .5,
        gridTextColor: "#888",
        gridTextSize: 12,
        gridTextFamily: "sans-serif",
        gridTextWeight: "normal",
        hideHover: !1,
        yLabelFormat: null,
        xLabelAngle: 0,
        numLines: 5,
        padding: 25,
        parseTime: !0,
        postUnits: "",
        preUnits: "",
        ymax: "auto",
        ymin: "auto 0",
        goals: [],
        goalStrokeWidth: 1,
        goalLineColors: ["#666633", "#999966", "#cc6666", "#663333"],
        events: [],
        eventStrokeWidth: 1,
        eventLineColors: ["#005a04", "#ccffbb", "#3a5f0b", "#005502"],
        rangeSelect: null,
        rangeSelectColor: "#eef",
        resize: !1
    }, b.prototype.setData = function(o, t) {
        var s, n, r, i, e, h, a, l, p, u, d, c, f, g, m;
        return null == t && (t = !0), null == (this.options.data = o) || 0 === o.length ? (this.data = [], this.raphael.clear(), void(null != this.hover && this.hover.hide())) : (c = this.cumulative ? 0 : null, f = this.cumulative ? 0 : null, 0 < this.options.goals.length && (e = Math.min.apply(Math, this.options.goals), i = Math.max.apply(Math, this.options.goals), f = null != f ? Math.min(f, e) : e, c = null != c ? Math.max(c, i) : i), this.data = function() {
            var t, i, e;
            for (e = [], r = t = 0, i = o.length; t < i; r = ++t) a = o[r], (h = {
                src: a
            }).label = a[this.options.xkey], this.options.parseTime ? (h.x = M.parseDate(h.label), this.options.dateFormat ? h.label = this.options.dateFormat(h.x) : "number" == typeof h.label && (h.label = new Date(h.label).toString())) : (h.x = r, this.options.xLabelFormat && (h.label = this.options.xLabelFormat(h))), p = 0, h.y = function() {
                var t, i, e, o;
                for (e = this.options.ykeys, o = [], n = t = 0, i = e.length; t < i; n = ++t) d = e[n], "string" == typeof(g = a[d]) && (g = parseFloat(g)), null != g && "number" != typeof g && (g = null), null != g && (this.cumulative ? p += g : null != c ? (c = Math.max(g, c), f = Math.min(g, f)) : c = f = g), this.cumulative && null != p && (c = Math.max(p, c), f = Math.min(p, f)), o.push(g);
                return o
            }.call(this), e.push(h);
            return e
        }.call(this), this.options.parseTime && (this.data = this.data.sort(function(t, i) {
            return (t.x > i.x) - (i.x > t.x)
        })), this.xmin = this.data[0].x, this.xmax = this.data[this.data.length - 1].x, this.events = [], 0 < this.options.events.length && (this.events = this.options.parseTime ? function() {
            var t, i, e, o;
            for (o = [], t = 0, i = (e = this.options.events).length; t < i; t++) s = e[t], o.push(M.parseDate(s));
            return o
        }.call(this) : this.options.events, this.xmax = Math.max(this.xmax, Math.max.apply(Math, this.events)), this.xmin = Math.min(this.xmin, Math.min.apply(Math, this.events))), this.xmin === this.xmax && (--this.xmin, this.xmax += 1), this.ymin = this.yboundary("min", f), this.ymax = this.yboundary("max", c), this.ymin === this.ymax && (f && --this.ymin, this.ymax += 1), !0 !== (m = this.options.axes) && "both" !== m && "y" !== m && !0 !== this.options.grid || (this.options.ymax === this.gridDefaults.ymax && this.options.ymin === this.gridDefaults.ymin ? (this.grid = this.autoGridLines(this.ymin, this.ymax, this.options.numLines), this.ymin = Math.min(this.ymin, this.grid[0]), this.ymax = Math.max(this.ymax, this.grid[this.grid.length - 1])) : (l = (this.ymax - this.ymin) / (this.options.numLines - 1), this.grid = function() {
            var t, i, e;
            for (e = [], u = t = this.ymin, i = this.ymax; 0 < l ? t <= i : i <= t; u = t += l) e.push(u);
            return e
        }.call(this))), this.dirty = !0, t ? this.redraw() : void 0)
    }, b.prototype.yboundary = function(t, i) {
        var e, o;
        return "string" == typeof(e = this.options["y" + t]) ? "auto" === e.slice(0, 4) ? 5 < e.length ? (o = parseInt(e.slice(5), 10), null == i ? o : Math[t](i, o)) : null != i ? i : 0 : parseInt(e, 10) : e
    }, b.prototype.autoGridLines = function(t, i, e) {
        var o, s, n, r, h, a, l, p;
        return r = i - t, p = Math.floor(Math.log(r) / Math.log(10)), a = Math.pow(10, p), s = Math.floor(t / a) * a, o = Math.ceil(i / a) * a, h = (o - s) / (e - 1), 1 === a && 1 < h && Math.ceil(h) !== h && (h = Math.ceil(h), o = s + h * (e - 1)), s < 0 && 0 < o && (s = Math.floor(t / h) * h, o = Math.ceil(i / h) * h), h < 1 ? (n = Math.floor(Math.log(h) / Math.log(10)), function() {
            var t, i;
            for (i = [], l = t = s; 0 < h ? t <= o : o <= t; l = t += h) i.push(parseFloat(l.toFixed(1 - n)));
            return i
        }()) : function() {
            var t, i;
            for (i = [], l = t = s; 0 < h ? t <= o : o <= t; l = t += h) i.push(l);
            return i
        }()
    }, b.prototype._calc = function() {
        var t, s, i, o, e, n, r, h;
        return e = this.el.width(), i = this.el.height(), (this.elementWidth !== e || this.elementHeight !== i || this.dirty) && (this.elementWidth = e, this.elementHeight = i, this.dirty = !1, this.left = this.options.padding, this.right = this.elementWidth - this.options.padding, this.top = this.options.padding, this.bottom = this.elementHeight - this.options.padding, !0 !== (r = this.options.axes) && "both" !== r && "y" !== r || (n = function() {
            var t, i, e, o;
            for (o = [], t = 0, i = (e = this.grid).length; t < i; t++) s = e[t], o.push(this.measureText(this.yAxisFormat(s)).width);
            return o
        }.call(this), this.left += Math.max.apply(Math, n)), !0 !== (h = this.options.axes) && "both" !== h && "x" !== h || (t = function() {
            var t, i, e;
            for (e = [], o = t = 0, i = this.data.length; 0 <= i ? t < i : i < t; o = 0 <= i ? ++t : --t) e.push(this.measureText(this.data[o].text, -this.options.xLabelAngle).height);
            return e
        }.call(this), this.bottom -= Math.max.apply(Math, t)), this.width = Math.max(1, this.right - this.left), this.height = Math.max(1, this.bottom - this.top), this.dx = this.width / (this.xmax - this.xmin), this.dy = this.height / (this.ymax - this.ymin), this.calc) ? this.calc() : void 0
    }, b.prototype.transY = function(t) {
        return this.bottom - (t - this.ymin) * this.dy
    }, b.prototype.transX = function(t) {
        return 1 === this.data.length ? (this.left + this.right) / 2 : this.left + (t - this.xmin) * this.dx
    }, b.prototype.redraw = function() {
        return this.raphael.clear(), this._calc(), this.drawGrid(), this.drawGoals(), this.drawEvents(), this.draw ? this.draw() : void 0
    }, b.prototype.measureText = function(t, i) {
        var e, o;
        return null == i && (i = 0), e = (o = this.raphael.text(100, 100, t).attr("font-size", this.options.gridTextSize).attr("font-family", this.options.gridTextFamily).attr("font-weight", this.options.gridTextWeight).rotate(i)).getBBox(), o.remove(), e
    }, b.prototype.yAxisFormat = function(t) {
        return this.yLabelFormat(t)
    }, b.prototype.yLabelFormat = function(t) {
        return "function" == typeof this.options.yLabelFormat ? this.options.yLabelFormat(t) : "" + this.options.preUnits + M.commas(t) + this.options.postUnits
    }, b.prototype.drawGrid = function() {
        var t, i, e, o, s, n, r, h;
        if (!1 !== this.options.grid || !0 === (s = this.options.axes) || "both" === s || "y" === s) {
            for (h = [], e = 0, o = (n = this.grid).length; e < o; e++) t = n[e], i = this.transY(t), !0 !== (r = this.options.axes) && "both" !== r && "y" !== r || this.drawYAxisLabel(this.left - this.options.padding / 2, i, this.yAxisFormat(t)), this.options.grid ? h.push(this.drawGridLine("M" + this.left + "," + i + "H" + (this.left + this.width))) : h.push(void 0);
            return h
        }
    }, b.prototype.drawGoals = function() {
        var t, i, e, o, s, n, r;
        for (r = [], e = o = 0, s = (n = this.options.goals).length; o < s; e = ++o) i = n[e], t = this.options.goalLineColors[e % this.options.goalLineColors.length], r.push(this.drawGoal(i, t));
        return r
    }, b.prototype.drawEvents = function() {
        var t, i, e, o, s, n, r;
        for (r = [], e = o = 0, s = (n = this.events).length; o < s; e = ++o) i = n[e], t = this.options.eventLineColors[e % this.options.eventLineColors.length], r.push(this.drawEvent(i, t));
        return r
    }, b.prototype.drawGoal = function(t, i) {
        return this.raphael.path("M" + this.left + "," + this.transY(t) + "H" + this.right).attr("stroke", i).attr("stroke-width", this.options.goalStrokeWidth)
    }, b.prototype.drawEvent = function(t, i) {
        return this.raphael.path("M" + this.transX(t) + "," + this.bottom + "V" + this.top).attr("stroke", i).attr("stroke-width", this.options.eventStrokeWidth)
    }, b.prototype.drawYAxisLabel = function(t, i, e) {
        return this.raphael.text(t, i, e).attr("font-size", this.options.gridTextSize).attr("font-family", this.options.gridTextFamily).attr("font-weight", this.options.gridTextWeight).attr("fill", this.options.gridTextColor).attr("text-anchor", "end")
    }, b.prototype.drawGridLine = function(t) {
        return this.raphael.path(t).attr("stroke", this.options.gridLineColor).attr("stroke-width", this.options.gridStrokeWidth)
    }, b.prototype.startRange = function(t) {
        return this.hover.hide(), this.selectFrom = t, this.selectionRect.attr({
            x: t,
            width: 0
        }).show()
    }, b.prototype.endRange = function(t) {
        var i, e;
        return this.selectFrom ? (e = Math.min(this.selectFrom, t), i = Math.max(this.selectFrom, t), this.options.rangeSelect.call(this.el, {
            start: this.data[this.hitTest(e)].x,
            end: this.data[this.hitTest(i)].x
        }), this.selectFrom = null) : void 0
    }, b.prototype.resizeHandler = function() {
        return this.timeoutId = null, this.raphael.setSize(this.el.width(), this.el.height()), this.redraw()
    }, b), M.parseDate = function(t) {
        var i, e, o, s, n, r, h, a, l, p, u;
        return "number" == typeof t ? t : (e = t.match(/^(\d+) Q(\d)$/), s = t.match(/^(\d+)-(\d+)$/), n = t.match(/^(\d+)-(\d+)-(\d+)$/), h = t.match(/^(\d+) W(\d+)$/), a = t.match(/^(\d+)-(\d+)-(\d+)[ T](\d+):(\d+)(Z|([+-])(\d\d):?(\d\d))?$/), l = t.match(/^(\d+)-(\d+)-(\d+)[ T](\d+):(\d+):(\d+(\.\d+)?)(Z|([+-])(\d\d):?(\d\d))?$/), e ? new Date(parseInt(e[1], 10), 3 * parseInt(e[2], 10) - 1, 1).getTime() : s ? new Date(parseInt(s[1], 10), parseInt(s[2], 10) - 1, 1).getTime() : n ? new Date(parseInt(n[1], 10), parseInt(n[2], 10) - 1, parseInt(n[3], 10)).getTime() : h ? (4 !== (p = new Date(parseInt(h[1], 10), 0, 1)).getDay() && p.setMonth(0, 1 + (4 - p.getDay() + 7) % 7), p.getTime() + 6048e5 * parseInt(h[2], 10)) : a ? a[6] ? (r = 0, "Z" !== a[6] && (r = 60 * parseInt(a[8], 10) + parseInt(a[9], 10), "+" === a[7] && (r = 0 - r)), Date.UTC(parseInt(a[1], 10), parseInt(a[2], 10) - 1, parseInt(a[3], 10), parseInt(a[4], 10), parseInt(a[5], 10) + r)) : new Date(parseInt(a[1], 10), parseInt(a[2], 10) - 1, parseInt(a[3], 10), parseInt(a[4], 10), parseInt(a[5], 10)).getTime() : l ? (u = parseFloat(l[6]), i = Math.floor(u), o = Math.round(1e3 * (u - i)), l[8] ? (r = 0, "Z" !== l[8] && (r = 60 * parseInt(l[10], 10) + parseInt(l[11], 10), "+" === l[9] && (r = 0 - r)), Date.UTC(parseInt(l[1], 10), parseInt(l[2], 10) - 1, parseInt(l[3], 10), parseInt(l[4], 10), parseInt(l[5], 10) + r, i, o)) : new Date(parseInt(l[1], 10), parseInt(l[2], 10) - 1, parseInt(l[3], 10), parseInt(l[4], 10), parseInt(l[5], 10), i, o).getTime()) : new Date(parseInt(t, 10), 0, 1).getTime())
    }, M.Hover = (w.defaults = {
        class: "morris-hover morris-default-style"
    }, w.prototype.update = function(t, i, e) {
        return t ? (this.html(t), this.show(), this.moveTo(i, e)) : this.hide()
    }, w.prototype.html = function(t) {
        return this.el.html(t)
    }, w.prototype.moveTo = function(t, i) {
        var e, o, s, n, r, h;
        return r = this.options.parent.innerWidth(), n = this.options.parent.innerHeight(), o = this.el.outerWidth(), e = this.el.outerHeight(), s = Math.min(Math.max(0, t - o / 2), r - o), null != i ? (h = i - e - 10) < 0 && n < (h = i + 10) + e && (h = n / 2 - e / 2) : h = n / 2 - e / 2, this.el.css({
            left: s + "px",
            top: parseInt(h) + "px"
        })
    }, w.prototype.show = function() {
        return this.el.show()
    }, w.prototype.hide = function() {
        return this.el.hide()
    }, w), M.Line = (a = M.Grid, t(x, a), x.prototype.init = function() {
        return "always" !== this.options.hideHover ? (this.hover = new M.Hover({
            parent: this.el
        }), this.on("hovermove", this.onHoverMove), this.on("hoverout", this.onHoverOut), this.on("gridclick", this.onGridClick)) : void 0
    }, x.prototype.defaults = {
        lineWidth: 3,
        pointSize: 4,
        lineColors: ["#0b62a4", "#7A92A3", "#4da74d", "#afd8f8", "#edc240", "#cb4b4b", "#9440ed"],
        pointStrokeWidths: [1],
        pointStrokeColors: ["#ffffff"],
        pointFillColors: [],
        smooth: !0,
        xLabels: "auto",
        xLabelFormat: null,
        xLabelMargin: 24,
        hideHover: !1
    }, x.prototype.calc = function() {
        return this.calcPoints(), this.generatePaths()
    }, x.prototype.calcPoints = function() {
        var s, n, t, i, e, o;
        for (o = [], t = 0, i = (e = this.data).length; t < i; t++)(s = e[t])._x = this.transX(s.x), s._y = function() {
            var t, i, e, o;
            for (o = [], t = 0, i = (e = s.y).length; t < i; t++) null != (n = e[t]) ? o.push(this.transY(n)) : o.push(n);
            return o
        }.call(this), o.push(s._ymax = Math.min.apply(Math, [this.bottom].concat(function() {
            var t, i, e, o;
            for (o = [], t = 0, i = (e = s._y).length; t < i; t++) null != (n = e[t]) && o.push(n);
            return o
        }())));
        return o
    }, x.prototype.hitTest = function(t) {
        var i, e, o, s;
        if (0 === this.data.length) return null;
        for (i = e = 0, o = (s = this.data.slice(1)).length; e < o && !(t < (s[i]._x + this.data[i]._x) / 2); i = ++e);
        return i
    }, x.prototype.onGridClick = function(t, i) {
        var e;
        return e = this.hitTest(t), this.fire("click", e, this.data[e].src, t, i)
    }, x.prototype.onHoverMove = function(t) {
        var i;
        return i = this.hitTest(t), this.displayHoverForRow(i)
    }, x.prototype.onHoverOut = function() {
        return !1 !== this.options.hideHover ? this.displayHoverForRow(null) : void 0
    }, x.prototype.displayHoverForRow = function(t) {
        var i;
        return null != t ? ((i = this.hover).update.apply(i, this.hoverContentForRow(t)), this.hilight(t)) : (this.hover.hide(), this.hilight())
    }, x.prototype.hoverContentForRow = function(t) {
        var i, e, o, s, n, r, h;
        for (i = "<div class='morris-hover-row-label'>" + (o = this.data[t]).label + "</div>", e = n = 0, r = (h = o.y).length; n < r; e = ++n) s = h[e], i += "<div class='morris-hover-point' style='color: " + this.colorFor(o, e, "label") + "'>\n  " + this.options.labels[e] + ":\n  " + this.yLabelFormat(s) + "\n</div>";
        return "function" == typeof this.options.hoverCallback && (i = this.options.hoverCallback(t, this.options, i, o.src)), [i, o._x, o._ymax]
    }, x.prototype.generatePaths = function() {
        var s, n, r, h;
        return this.paths = function() {
            var t, i, e, o;
            for (o = [], n = t = 0, i = this.options.ykeys.length; 0 <= i ? t < i : i < t; n = 0 <= i ? ++t : --t) h = "boolean" == typeof this.options.smooth ? this.options.smooth : (e = this.options.ykeys[n], 0 <= c.call(this.options.smooth, e)), 1 < (s = function() {
                var t, i, e, o;
                for (o = [], t = 0, i = (e = this.data).length; t < i; t++) void 0 !== (r = e[t])._y[n] && o.push({
                    x: r._x,
                    y: r._y[n]
                });
                return o
            }.call(this)).length ? o.push(M.Line.createPath(s, h, this.bottom)) : o.push(null);
            return o
        }.call(this)
    }, x.prototype.draw = function() {
        var t;
        return !0 !== (t = this.options.axes) && "both" !== t && "x" !== t || this.drawXAxis(), this.drawSeries(), !1 === this.options.hideHover ? this.displayHoverForRow(this.data.length - 1) : void 0
    }, x.prototype.drawXAxis = function() {
        var t, i, e, h, a, s, l, o, n, r, p = this;
        for (l = this.bottom + this.options.padding / 2, h = a = null, t = function(t, i) {
                var e, o, s, n, r;
                return r = (e = p.drawXAxisLabel(p.transX(i), l, t)).getBBox(), e.transform("r" + -p.options.xLabelAngle), o = e.getBBox(), e.transform("t0," + o.height / 2 + "..."), 0 !== p.options.xLabelAngle && (n = -.5 * r.width * Math.cos(p.options.xLabelAngle * Math.PI / 180), e.transform("t" + n + ",0...")), o = e.getBBox(), (null == a || a >= o.x + o.width || null != h && h >= o.x) && 0 <= o.x && o.x + o.width < p.el.width() ? (0 !== p.options.xLabelAngle && (s = 1.25 * p.options.gridTextSize / Math.sin(p.options.xLabelAngle * Math.PI / 180), h = o.x - s), a = o.x - p.options.xLabelMargin) : e.remove()
            }, (e = this.options.parseTime ? 1 === this.data.length && "auto" === this.options.xLabels ? [
                [this.data[0].label, this.data[0].x]
            ] : M.labelSeries(this.xmin, this.xmax, this.width, this.options.xLabels, this.options.xLabelFormat) : function() {
                var t, i, e, o;
                for (o = [], t = 0, i = (e = this.data).length; t < i; t++) s = e[t], o.push([s.label, s.x]);
                return o
            }.call(this)).reverse(), r = [], o = 0, n = e.length; o < n; o++) i = e[o], r.push(t(i[0], i[1]));
        return r
    }, x.prototype.drawSeries = function() {
        var t, i, e, o, s, n;
        for (this.seriesPoints = [], t = i = o = this.options.ykeys.length - 1; o <= 0 ? i <= 0 : 0 <= i; t = o <= 0 ? ++i : --i) this._drawLineFor(t);
        for (n = [], t = e = s = this.options.ykeys.length - 1; s <= 0 ? e <= 0 : 0 <= e; t = s <= 0 ? ++e : --e) n.push(this._drawPointFor(t));
        return n
    }, x.prototype._drawPointFor = function(t) {
        var i, e, o, s, n, r;
        for (this.seriesPoints[t] = [], r = [], o = 0, s = (n = this.data).length; o < s; o++)(i = null) != (e = n[o])._y[t] && (i = this.drawLinePoint(e._x, e._y[t], this.colorFor(e, t, "point"), t)), r.push(this.seriesPoints[t].push(i));
        return r
    }, x.prototype._drawLineFor = function(t) {
        var i;
        return null !== (i = this.paths[t]) ? this.drawLinePath(i, this.colorFor(null, t, "line"), t) : void 0
    }, x.createPath = function(t, i, e) {
        var o, s, n, r, h, a, l, p, u, d;
        for (l = "", i && (n = M.Line.gradients(t)), p = {
                y: null
            }, r = u = 0, d = t.length; u < d; r = ++u) null != (o = t[r]).y && (null != p.y ? i ? (s = n[r], a = n[r - 1], h = (o.x - p.x) / 4, l += "C" + (p.x + h) + "," + Math.min(e, p.y + h * a) + "," + (o.x - h) + "," + Math.min(e, o.y - h * s) + "," + o.x + "," + o.y) : l += "L" + o.x + "," + o.y : i && null == n[r] || (l += "M" + o.x + "," + o.y)), p = o;
        return l
    }, x.gradients = function(t) {
        var i, e, o, s, n, r, h, a;
        for (e = function(t, i) {
                return (t.y - i.y) / (t.x - i.x)
            }, a = [], o = r = 0, h = t.length; r < h; o = ++r) null != (i = t[o]).y ? (s = t[o + 1] || {
            y: null
        }, null != (n = t[o - 1] || {
            y: null
        }).y && null != s.y ? a.push(e(n, s)) : null != n.y ? a.push(e(n, i)) : null != s.y ? a.push(e(i, s)) : a.push(null)) : a.push(null);
        return a
    }, x.prototype.hilight = function(t) {
        var i, e, o, s, n;
        if (null !== this.prevHilight && this.prevHilight !== t)
            for (i = e = 0, s = this.seriesPoints.length - 1; 0 <= s ? e <= s : s <= e; i = 0 <= s ? ++e : --e) this.seriesPoints[i][this.prevHilight] && this.seriesPoints[i][this.prevHilight].animate(this.pointShrinkSeries(i));
        if (null !== t && this.prevHilight !== t)
            for (i = o = 0, n = this.seriesPoints.length - 1; 0 <= n ? o <= n : n <= o; i = 0 <= n ? ++o : --o) this.seriesPoints[i][t] && this.seriesPoints[i][t].animate(this.pointGrowSeries(i));
        return this.prevHilight = t
    }, x.prototype.colorFor = function(t, i, e) {
        return "function" == typeof this.options.lineColors ? this.options.lineColors.call(this, t, i, e) : "point" === e && this.options.pointFillColors[i % this.options.pointFillColors.length] || this.options.lineColors[i % this.options.lineColors.length]
    }, x.prototype.drawXAxisLabel = function(t, i, e) {
        return this.raphael.text(t, i, e).attr("font-size", this.options.gridTextSize).attr("font-family", this.options.gridTextFamily).attr("font-weight", this.options.gridTextWeight).attr("fill", this.options.gridTextColor)
    }, x.prototype.drawLinePath = function(t, i, e) {
        return this.raphael.path(t).attr("stroke", i).attr("stroke-width", this.lineWidthForSeries(e))
    }, x.prototype.drawLinePoint = function(t, i, e, o) {
        return this.raphael.circle(t, i, this.pointSizeForSeries(o)).attr("fill", e).attr("stroke-width", this.pointStrokeWidthForSeries(o)).attr("stroke", this.pointStrokeColorForSeries(o))
    }, x.prototype.pointStrokeWidthForSeries = function(t) {
        return this.options.pointStrokeWidths[t % this.options.pointStrokeWidths.length]
    }, x.prototype.pointStrokeColorForSeries = function(t) {
        return this.options.pointStrokeColors[t % this.options.pointStrokeColors.length]
    }, x.prototype.lineWidthForSeries = function(t) {
        return this.options.lineWidth instanceof Array ? this.options.lineWidth[t % this.options.lineWidth.length] : this.options.lineWidth
    }, x.prototype.pointSizeForSeries = function(t) {
        return this.options.pointSize instanceof Array ? this.options.pointSize[t % this.options.pointSize.length] : this.options.pointSize
    }, x.prototype.pointGrowSeries = function(t) {
        return Raphael.animation({
            r: this.pointSizeForSeries(t) + 3
        }, 25, "linear")
    }, x.prototype.pointShrinkSeries = function(t) {
        return Raphael.animation({
            r: this.pointSizeForSeries(t)
        }, 25, "linear")
    }, x), M.labelSeries = function(t, i, e, o, s) {
        var n, r, h, a, l, p, u, d, c, f, g;
        if (h = 200 * (i - t) / e, r = new Date(t), void 0 === (u = M.LABEL_SPECS[o]))
            for (c = 0, f = (g = M.AUTO_LABEL_ORDER).length; c < f; c++)
                if (a = g[c], h >= (p = M.LABEL_SPECS[a]).span) {
                    u = p;
                    break
                }
        for (void 0 === u && (u = M.LABEL_SPECS.second), s && (u = m.extend({}, u, {
                fmt: s
            })), n = u.start(r), l = [];
            (d = n.getTime()) <= i;) t <= d && l.push([u.fmt(n), d]), u.incr(n);
        return l
    }, i = function(i) {
        return {
            span: 60 * i * 1e3,
            start: function(t) {
                return new Date(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours())
            },
            fmt: function(t) {
                return M.pad2(t.getHours()) + ":" + M.pad2(t.getMinutes())
            },
            incr: function(t) {
                return t.setUTCMinutes(t.getUTCMinutes() + i)
            }
        }
    }, e = function(i) {
        return {
            span: 1e3 * i,
            start: function(t) {
                return new Date(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes())
            },
            fmt: function(t) {
                return M.pad2(t.getHours()) + ":" + M.pad2(t.getMinutes()) + ":" + M.pad2(t.getSeconds())
            },
            incr: function(t) {
                return t.setUTCSeconds(t.getUTCSeconds() + i)
            }
        }
    }, M.LABEL_SPECS = {
        decade: {
            span: 1728e8,
            start: function(t) {
                return new Date(t.getFullYear() - t.getFullYear() % 10, 0, 1)
            },
            fmt: function(t) {
                return "" + t.getFullYear()
            },
            incr: function(t) {
                return t.setFullYear(t.getFullYear() + 10)
            }
        },
        year: {
            span: 1728e7,
            start: function(t) {
                return new Date(t.getFullYear(), 0, 1)
            },
            fmt: function(t) {
                return "" + t.getFullYear()
            },
            incr: function(t) {
                return t.setFullYear(t.getFullYear() + 1)
            }
        },
        month: {
            span: 24192e5,
            start: function(t) {
                return new Date(t.getFullYear(), t.getMonth(), 1)
            },
            fmt: function(t) {
                return t.getFullYear() + "-" + M.pad2(t.getMonth() + 1)
            },
            incr: function(t) {
                return t.setMonth(t.getMonth() + 1)
            }
        },
        week: {
            span: 6048e5,
            start: function(t) {
                return new Date(t.getFullYear(), t.getMonth(), t.getDate())
            },
            fmt: function(t) {
                return t.getFullYear() + "-" + M.pad2(t.getMonth() + 1) + "-" + M.pad2(t.getDate())
            },
            incr: function(t) {
                return t.setDate(t.getDate() + 7)
            }
        },
        day: {
            span: 864e5,
            start: function(t) {
                return new Date(t.getFullYear(), t.getMonth(), t.getDate())
            },
            fmt: function(t) {
                return t.getFullYear() + "-" + M.pad2(t.getMonth() + 1) + "-" + M.pad2(t.getDate())
            },
            incr: function(t) {
                return t.setDate(t.getDate() + 1)
            }
        },
        hour: i(60),
        "30min": i(30),
        "15min": i(15),
        "10min": i(10),
        "5min": i(5),
        minute: i(1),
        "30sec": e(30),
        "15sec": e(15),
        "10sec": e(10),
        "5sec": e(5),
        second: e(1)
    }, M.AUTO_LABEL_ORDER = ["decade", "year", "month", "week", "day", "hour", "30min", "15min", "10min", "5min", "minute", "30sec", "15sec", "10sec", "5sec", "second"], M.Area = (r = M.Line, t(v, r), h = {
        fillOpacity: "auto",
        behaveLikeLine: !1
    }, v.prototype.calcPoints = function() {
        var s, n, r, t, i, e, o;
        for (o = [], t = 0, i = (e = this.data).length; t < i; t++)(s = e[t])._x = this.transX(s.x), n = 0, s._y = function() {
            var t, i, e, o;
            for (o = [], t = 0, i = (e = s.y).length; t < i; t++) r = e[t], this.options.behaveLikeLine ? o.push(this.transY(r)) : (n += r || 0, o.push(this.transY(n)));
            return o
        }.call(this), o.push(s._ymax = Math.max.apply(Math, s._y));
        return o
    }, v.prototype.drawSeries = function() {
        var t, i, e, o, s, n, r, h;
        for (this.seriesPoints = [], h = [], e = 0, o = (i = this.options.behaveLikeLine ? function() {
                n = [];
                for (var t = 0, i = this.options.ykeys.length - 1; 0 <= i ? t <= i : i <= t; 0 <= i ? t++ : t--) n.push(t);
                return n
            }.apply(this) : function() {
                r = [];
                for (var t = s = this.options.ykeys.length - 1; s <= 0 ? t <= 0 : 0 <= t; s <= 0 ? t++ : t--) r.push(t);
                return r
            }.apply(this)).length; e < o; e++) t = i[e], this._drawFillFor(t), this._drawLineFor(t), h.push(this._drawPointFor(t));
        return h
    }, v.prototype._drawFillFor = function(t) {
        var i;
        return null !== (i = this.paths[t]) ? (i += "L" + this.transX(this.xmax) + "," + this.bottom + "L" + this.transX(this.xmin) + "," + this.bottom + "Z", this.drawFilledPath(i, this.fillForSeries(t))) : void 0
    }, v.prototype.fillForSeries = function(t) {
        var i;
        return i = Raphael.rgb2hsl(this.colorFor(this.data[t], t, "line")), Raphael.hsl(i.h, this.options.behaveLikeLine ? .9 * i.s : .75 * i.s, Math.min(.98, this.options.behaveLikeLine ? 1.2 * i.l : 1.25 * i.l))
    }, v.prototype.drawFilledPath = function(t, i) {
        return this.raphael.path(t).attr("fill", i).attr("fill-opacity", this.options.fillOpacity).attr("stroke", "none")
    }, v), M.Bar = (n = M.Grid, t(y, n), y.prototype.init = function() {
        return this.cumulative = this.options.stacked, "always" !== this.options.hideHover ? (this.hover = new M.Hover({
            parent: this.el
        }), this.on("hovermove", this.onHoverMove), this.on("hoverout", this.onHoverOut), this.on("gridclick", this.onGridClick)) : void 0
    }, y.prototype.defaults = {
        barSizeRatio: .75,
        barGap: 3,
        barColors: ["#0b62a4", "#7a92a3", "#4da74d", "#afd8f8", "#edc240", "#cb4b4b", "#9440ed"],
        barOpacity: 1,
        barRadius: [0, 0, 0, 0],
        xLabelMargin: 50
    }, y.prototype.calc = function() {
        var t;
        return this.calcBars(), !1 === this.options.hideHover ? (t = this.hover).update.apply(t, this.hoverContentForRow(this.data.length - 1)) : void 0
    }, y.prototype.calcBars = function() {
        var t, s, n, i, e, o, r;
        for (r = [], t = i = 0, e = (o = this.data).length; i < e; t = ++i)(s = o[t])._x = this.left + this.width * (t + .5) / this.data.length, r.push(s._y = function() {
            var t, i, e, o;
            for (o = [], t = 0, i = (e = s.y).length; t < i; t++) null != (n = e[t]) ? o.push(this.transY(n)) : o.push(null);
            return o
        }.call(this));
        return r
    }, y.prototype.draw = function() {
        var t;
        return !0 !== (t = this.options.axes) && "both" !== t && "x" !== t || this.drawXAxis(), this.drawSeries()
    }, y.prototype.drawXAxis = function() {
        var t, i, e, o, s, n, r, h, a, l, p, u, d;
        for (l = this.bottom + (this.options.xAxisLabelTopPadding || this.options.padding / 2), n = r = null, d = [], t = p = 0, u = this.data.length; 0 <= u ? p < u : u < p; t = 0 <= u ? ++p : --p) h = this.data[this.data.length - 1 - t], a = (i = this.drawXAxisLabel(h._x, l, h.label)).getBBox(), i.transform("r" + -this.options.xLabelAngle), e = i.getBBox(), i.transform("t0," + e.height / 2 + "..."), 0 !== this.options.xLabelAngle && (s = -.5 * a.width * Math.cos(this.options.xLabelAngle * Math.PI / 180), i.transform("t" + s + ",0...")), (null == r || r >= e.x + e.width || null != n && n >= e.x) && 0 <= e.x && e.x + e.width < this.el.width() ? (0 !== this.options.xLabelAngle && (o = 1.25 * this.options.gridTextSize / Math.sin(this.options.xLabelAngle * Math.PI / 180), n = e.x - o), d.push(r = e.x - this.options.xLabelMargin)) : d.push(i.remove());
        return d
    }, y.prototype.drawSeries = function() {
        var s, n, r, h, a, l, p, t, u, d, c, i, f, g, m;
        return r = this.width / this.options.data.length, t = this.options.stacked ? 1 : this.options.ykeys.length, s = (r * this.options.barSizeRatio - this.options.barGap * (t - 1)) / t, this.options.barSize && (s = Math.min(s, this.options.barSize)), i = r - s * t - this.options.barGap * (t - 1), p = i / 2, m = this.ymin <= 0 && 0 <= this.ymax ? this.transY(0) : null, this.bars = function() {
            var t, i, e, o;
            for (e = this.data, o = [], h = t = 0, i = e.length; t < i; h = ++t) u = e[h], a = 0, o.push(function() {
                var t, i, e, o;
                for (e = u._y, o = [], d = t = 0, i = e.length; t < i; d = ++t) null !== (g = e[d]) ? (n = m ? (f = Math.min(g, m), Math.max(g, m)) : (f = g, this.bottom), l = this.left + h * r + p, this.options.stacked || (l += d * (s + this.options.barGap)), c = n - f, this.options.verticalGridCondition && this.options.verticalGridCondition(u.x) && this.drawBar(this.left + h * r, this.top, r, Math.abs(this.top - this.bottom), this.options.verticalGridColor, this.options.verticalGridOpacity, this.options.barRadius), this.options.stacked && (f -= a), this.drawBar(l, f, s, c, this.colorFor(u, d, "bar"), this.options.barOpacity, this.options.barRadius), o.push(a += c)) : o.push(null);
                return o
            }.call(this));
            return o
        }.call(this)
    }, y.prototype.colorFor = function(t, i, e) {
        var o, s;
        return "function" == typeof this.options.barColors ? (o = {
            x: t.x,
            y: t.y[i],
            label: t.label
        }, s = {
            index: i,
            key: this.options.ykeys[i],
            label: this.options.labels[i]
        }, this.options.barColors.call(this, o, s, e)) : this.options.barColors[i % this.options.barColors.length]
    }, y.prototype.hitTest = function(t) {
        return 0 === this.data.length ? null : (t = Math.max(Math.min(t, this.right), this.left), Math.min(this.data.length - 1, Math.floor((t - this.left) / (this.width / this.data.length))))
    }, y.prototype.onGridClick = function(t, i) {
        var e;
        return e = this.hitTest(t), this.fire("click", e, this.data[e].src, t, i)
    }, y.prototype.onHoverMove = function(t) {
        var i, e;
        return i = this.hitTest(t), (e = this.hover).update.apply(e, this.hoverContentForRow(i))
    }, y.prototype.onHoverOut = function() {
        return !1 !== this.options.hideHover ? this.hover.hide() : void 0
    }, y.prototype.hoverContentForRow = function(t) {
        var i, e, o, s, n, r, h;
        for (i = "<div class='morris-hover-row-label'>" + (o = this.data[t]).label + "</div>", e = n = 0, r = (h = o.y).length; n < r; e = ++n) s = h[e], i += "<div class='morris-hover-point' style='color: " + this.colorFor(o, e, "label") + "'>\n  " + this.options.labels[e] + ":\n  " + this.yLabelFormat(s) + "\n</div>";
        return "function" == typeof this.options.hoverCallback && (i = this.options.hoverCallback(t, this.options, i, o.src)), [i, this.left + (t + .5) * this.width / this.data.length]
    }, y.prototype.drawXAxisLabel = function(t, i, e) {
        return this.raphael.text(t, i, e).attr("font-size", this.options.gridTextSize).attr("font-family", this.options.gridTextFamily).attr("font-weight", this.options.gridTextWeight).attr("fill", this.options.gridTextColor)
    }, y.prototype.drawBar = function(t, i, e, o, s, n, r) {
        var h;
        return (0 === (h = Math.max.apply(Math, r)) || o < h ? this.raphael.rect(t, i, e, o) : this.raphael.path(this.roundedRect(t, i, e, o, r))).attr("fill", s).attr("fill-opacity", n).attr("stroke", "none")
    }, y.prototype.roundedRect = function(t, i, e, o, s) {
        return null == s && (s = [0, 0, 0, 0]), ["M", t, s[0] + i, "Q", t, i, t + s[0], i, "L", t + e - s[1], i, "Q", t + e, i, t + e, i + s[1], "L", t + e, i + o - s[2], "Q", t + e, i + o, t + e - s[2], i + o, "L", t + s[3], i + o, "Q", t, i + o, t, i + o - s[3], "Z"]
    }, y), M.Donut = (s = M.EventEmitter, t(g, s), g.prototype.defaults = {
        colors: ["#0B62A4", "#3980B5", "#679DC6", "#95BBD7", "#B0CCE1", "#095791", "#095085", "#083E67", "#052C48", "#042135"],
        backgroundColor: "#FFFFFF",
        labelColor: "#000000",
        formatter: M.commas,
        resize: !1
    }, g.prototype.redraw = function() {
        var t, i, e, o, s, n, r, h, a, l, p, u, d, c, f, g, m, y, v, x, w, b;
        for (this.raphael.clear(), i = this.el.width() / 2, e = this.el.height() / 2, u = (Math.min(i, e) - 10) / 3, d = p = 0, g = (v = this.values).length; d < g; d++) p += v[d];
        for (h = 5 / (2 * u), t = 1.9999 * Math.PI - h * this.data.length, s = n = 0, this.segments = [], o = c = 0, m = (x = this.values).length; c < m; o = ++c) a = n + h + x[o] / p * t, (l = new M.DonutSegment(i, e, 2 * u, u, n, a, this.data[o].color || this.options.colors[s % this.options.colors.length], this.options.backgroundColor, s, this.raphael)).render(), this.segments.push(l), l.on("hover", this.select), l.on("click", this.click), n = a, s += 1;
        for (this.text1 = this.drawEmptyDonutLabel(i, e - 10, this.options.labelColor, 15, 800), this.text2 = this.drawEmptyDonutLabel(i, 10 + e, this.options.labelColor, 14), r = Math.max.apply(Math, this.values), b = [], f = s = 0, y = (w = this.values).length; f < y; f++) {
            if (w[f] === r) {
                this.select(s);
                break
            }
            b.push(s += 1)
        }
        return b
    }, g.prototype.setData = function(t) {
        var s;
        return this.data = t, this.values = function() {
            var t, i, e, o;
            for (o = [], t = 0, i = (e = this.data).length; t < i; t++) s = e[t], o.push(parseFloat(s.value));
            return o
        }.call(this), this.redraw()
    }, g.prototype.click = function(t) {
        return this.fire("click", t, this.data[t])
    }, g.prototype.select = function(t) {
        var i, e, o, s;
        for (e = 0, o = (s = this.segments).length; e < o; e++) s[e].deselect();
        return this.segments[t].select(), i = this.data[t], this.setLabels(i.label, this.options.formatter(i.value, i))
    }, g.prototype.setLabels = function(t, i) {
        var e, o, s, n, r, h, a, l;
        return n = 1.8 * (e = 2 * (Math.min(this.el.width() / 2, this.el.height() / 2) - 10) / 3), s = e / 2, o = e / 3, this.text1.attr({
            text: t,
            transform: ""
        }), r = this.text1.getBBox(), h = Math.min(n / r.width, s / r.height), this.text1.attr({
            transform: "S" + h + "," + h + "," + (r.x + r.width / 2) + "," + (r.y + r.height)
        }), this.text2.attr({
            text: i,
            transform: ""
        }), a = this.text2.getBBox(), l = Math.min(n / a.width, o / a.height), this.text2.attr({
            transform: "S" + l + "," + l + "," + (a.x + a.width / 2) + "," + a.y
        })
    }, g.prototype.drawEmptyDonutLabel = function(t, i, e, o, s) {
        var n;
        return n = this.raphael.text(t, i, "").attr("font-size", o).attr("fill", e), null != s && n.attr("font-weight", s), n
    }, g.prototype.resizeHandler = function() {
        return this.timeoutId = null, this.raphael.setSize(this.el.width(), this.el.height()), this.redraw()
    }, g), M.DonutSegment = (o = M.EventEmitter, t(f, o), f.prototype.calcArcPoints = function(t) {
        return [this.cx + t * this.sin_p0, this.cy + t * this.cos_p0, this.cx + t * this.sin_p1, this.cy + t * this.cos_p1]
    }, f.prototype.calcSegment = function(t, i) {
        var e, o, s, n, r, h, a, l, p, u;
        return e = (p = this.calcArcPoints(t))[0], s = p[1], o = p[2], n = p[3], r = (u = this.calcArcPoints(i))[0], a = u[1], h = u[2], l = u[3], "M" + e + "," + s + "A" + t + "," + t + ",0," + this.is_long + ",0," + o + "," + n + "L" + h + "," + l + "A" + i + "," + i + ",0," + this.is_long + ",1," + r + "," + a + "Z"
    }, f.prototype.calcArc = function(t) {
        var i, e, o, s, n;
        return i = (n = this.calcArcPoints(t))[0], o = n[1], e = n[2], s = n[3], "M" + i + "," + o + "A" + t + "," + t + ",0," + this.is_long + ",0," + e + "," + s
    }, f.prototype.render = function() {
        var t = this;
        return this.arc = this.drawDonutArc(this.hilight, this.color), this.seg = this.drawDonutSegment(this.path, this.color, this.backgroundColor, function() {
            return t.fire("hover", t.index)
        }, function() {
            return t.fire("click", t.index)
        })
    }, f.prototype.drawDonutArc = function(t, i) {
        return this.raphael.path(t).attr({
            stroke: i,
            "stroke-width": 2,
            opacity: 0
        })
    }, f.prototype.drawDonutSegment = function(t, i, e, o, s) {
        return this.raphael.path(t).attr({
            fill: i,
            stroke: e,
            "stroke-width": 3
        }).hover(o).click(s)
    }, f.prototype.select = function() {
        return this.selected ? void 0 : (this.seg.animate({
            path: this.selectedPath
        }, 150, "<>"), this.arc.animate({
            opacity: 1
        }, 150, "<>"), this.selected = !0)
    }, f.prototype.deselect = function() {
        return this.selected ? (this.seg.animate({
            path: this.path
        }, 150, "<>"), this.arc.animate({
            opacity: 0
        }, 150, "<>"), this.selected = !1) : void 0
    }, f)
}).call(this);
(function() {
    function p(t, i) {
        return function() {
            return t.apply(i, arguments)
        }
    }

    function t(t, i) {
        function e() {
            this.constructor = t
        }
        for (var o in i) d.call(i, o) && (t[o] = i[o]);
        return e.prototype = i.prototype, t.prototype = new e, t.__super__ = i.prototype, t
    }
    var m, M, i, e, o, s, n, r, h, a, l, u = [].slice,
        d = {}.hasOwnProperty,
        c = [].indexOf || function(t) {
            for (var i = 0, e = this.length; i < e; i++)
                if (i in this && this[i] === t) return i;
            return -1
        };

    function f(t, i, e, o, s, n, r, h, a, l) {
        this.cx = t, this.cy = i, this.inner = e, this.outer = o, this.color = r, this.backgroundColor = h, this.index = a, this.raphael = l, this.deselect = p(this.deselect, this), this.select = p(this.select, this), this.sin_p0 = Math.sin(s), this.cos_p0 = Math.cos(s), this.sin_p1 = Math.sin(n), this.cos_p1 = Math.cos(n), this.is_long = n - s > Math.PI ? 1 : 0, this.path = this.calcSegment(this.inner + 3, this.inner + this.outer - 5), this.selectedPath = this.calcSegment(this.inner + 3, this.inner + this.outer), this.hilight = this.calcArc(this.inner)
    }

    function g(t) {
        this.resizeHandler = p(this.resizeHandler, this), this.select = p(this.select, this), this.click = p(this.click, this);
        var i = this;
        if (!(this instanceof M.Donut)) return new M.Donut(t);
        if (this.options = m.extend({}, this.defaults, t), this.el = "string" == typeof t.element ? m(document.getElementById(t.element)) : m(t.element), null === this.el || 0 === this.el.length) throw new Error("Graph placeholder not found.");
        void 0 !== t.data && 0 !== t.data.length && (this.raphael = new Raphael(this.el[0]), this.options.resize && m(window).bind("resize", function() {
            return null != i.timeoutId && window.clearTimeout(i.timeoutId), i.timeoutId = window.setTimeout(i.resizeHandler, 100)
        }), this.setData(t.data))
    }

    function y(t) {
        return this.onHoverOut = p(this.onHoverOut, this), this.onHoverMove = p(this.onHoverMove, this), this.onGridClick = p(this.onGridClick, this), this instanceof M.Bar ? void y.__super__.constructor.call(this, m.extend({}, t, {
            parseTime: !1
        })) : new M.Bar(t)
    }

    function v(t) {
        var i;
        return this instanceof M.Area ? (i = m.extend({}, h, t), this.cumulative = !i.behaveLikeLine, "auto" === i.fillOpacity && (i.fillOpacity = i.behaveLikeLine ? .8 : 1), void v.__super__.constructor.call(this, i)) : new M.Area(t)
    }

    function x(t) {
        return this.hilight = p(this.hilight, this), this.onHoverOut = p(this.onHoverOut, this), this.onHoverMove = p(this.onHoverMove, this), this.onGridClick = p(this.onGridClick, this), this instanceof M.Line ? void x.__super__.constructor.call(this, t) : new M.Line(t)
    }

    function w(t) {
        null == t && (t = {}), this.options = m.extend({}, M.Hover.defaults, t), this.el = m("<div class='" + this.options.class + "'></div>"), this.el.hide(), this.options.parent.append(this.el)
    }

    function b(t) {
        this.resizeHandler = p(this.resizeHandler, this);
        var n = this;
        if (this.el = "string" == typeof t.element ? m(document.getElementById(t.element)) : m(t.element), null == this.el || 0 === this.el.length) throw new Error("Graph container element not found");
        "static" === this.el.css("position") && this.el.css("position", "relative"), this.options = m.extend({}, this.gridDefaults, this.defaults || {}, t), "string" == typeof this.options.units && (this.options.postUnits = t.units), this.raphael = new Raphael(this.el[0]), this.elementWidth = null, this.elementHeight = null, this.dirty = !1, this.selectFrom = null, this.init && this.init(), this.setData(this.options.data), this.el.bind("mousemove", function(t) {
            var i, e, o, s;
            return e = n.el.offset(), s = t.pageX - e.left, n.selectFrom ? (i = n.data[n.hitTest(Math.min(s, n.selectFrom))]._x, o = n.data[n.hitTest(Math.max(s, n.selectFrom))]._x - i, n.selectionRect.attr({
                x: i,
                width: o
            })) : n.fire("hovermove", s, t.pageY - e.top)
        }), this.el.bind("mouseleave", function() {
            return n.selectFrom && (n.selectionRect.hide(), n.selectFrom = null), n.fire("hoverout")
        }), this.el.bind("touchstart touchmove touchend", function(t) {
            var i, e;
            return e = t.originalEvent.touches[0] || t.originalEvent.changedTouches[0], i = n.el.offset(), n.fire("hovermove", e.pageX - i.left, e.pageY - i.top)
        }), this.el.bind("click", function(t) {
            var i;
            return i = n.el.offset(), n.fire("gridclick", t.pageX - i.left, t.pageY - i.top)
        }), this.options.rangeSelect && (this.selectionRect = this.raphael.rect(0, 0, 0, this.el.innerHeight()).attr({
            fill: this.options.rangeSelectColor,
            stroke: !1
        }).toBack().hide(), this.el.bind("mousedown", function(t) {
            var i;
            return i = n.el.offset(), n.startRange(t.pageX - i.left)
        }), this.el.bind("mouseup", function(t) {
            var i;
            return i = n.el.offset(), n.endRange(t.pageX - i.left), n.fire("hovermove", t.pageX - i.left, t.pageY - i.top)
        })), this.options.resize && m(window).bind("resize", function() {
            return null != n.timeoutId && window.clearTimeout(n.timeoutId), n.timeoutId = window.setTimeout(n.resizeHandler, 100)
        }), this.el.css("-webkit-tap-highlight-color", "rgba(0,0,0,0)"), this.postInit && this.postInit()
    }

    function F() {}
    M = window.Morris = {}, m = jQuery, M.EventEmitter = (F.prototype.on = function(t, i) {
        return null == this.handlers && (this.handlers = {}), null == this.handlers[t] && (this.handlers[t] = []), this.handlers[t].push(i), this
    }, F.prototype.fire = function() {
        var t, i, e, o, s, n, r;
        if (e = arguments[0], t = 2 <= arguments.length ? u.call(arguments, 1) : [], null != this.handlers && null != this.handlers[e]) {
            for (r = [], o = 0, s = (n = this.handlers[e]).length; o < s; o++) i = n[o], r.push(i.apply(null, t));
            return r
        }
    }, F), M.commas = function(t) {
        var i, e, o, s;
        return null != t ? (o = t < 0 ? "-" : "", i = Math.abs(t), o += (e = Math.floor(i).toFixed(0)).replace(/(?=(?:\d{3})+$)(?!^)/g, ","), (s = i.toString()).length > e.length && (o += s.slice(e.length)), o) : "-"
    }, M.pad2 = function(t) {
        return (t < 10 ? "0" : "") + t
    }, M.Grid = (l = M.EventEmitter, t(b, l), b.prototype.gridDefaults = {
        dateFormat: null,
        axes: !0,
        grid: !0,
        gridLineColor: "#aaa",
        gridStrokeWidth: .5,
        gridTextColor: "#888",
        gridTextSize: 12,
        gridTextFamily: "sans-serif",
        gridTextWeight: "normal",
        hideHover: !1,
        yLabelFormat: null,
        xLabelAngle: 0,
        numLines: 5,
        padding: 25,
        parseTime: !0,
        postUnits: "",
        preUnits: "",
        ymax: "auto",
        ymin: "auto 0",
        goals: [],
        goalStrokeWidth: 1,
        goalLineColors: ["#666633", "#999966", "#cc6666", "#663333"],
        events: [],
        eventStrokeWidth: 1,
        eventLineColors: ["#005a04", "#ccffbb", "#3a5f0b", "#005502"],
        rangeSelect: null,
        rangeSelectColor: "#eef",
        resize: !1
    }, b.prototype.setData = function(o, t) {
        var s, n, r, i, e, h, a, l, p, u, d, c, f, g, m;
        return null == t && (t = !0), null == (this.options.data = o) || 0 === o.length ? (this.data = [], this.raphael.clear(), void(null != this.hover && this.hover.hide())) : (c = this.cumulative ? 0 : null, f = this.cumulative ? 0 : null, 0 < this.options.goals.length && (e = Math.min.apply(Math, this.options.goals), i = Math.max.apply(Math, this.options.goals), f = null != f ? Math.min(f, e) : e, c = null != c ? Math.max(c, i) : i), this.data = function() {
            var t, i, e;
            for (e = [], r = t = 0, i = o.length; t < i; r = ++t) a = o[r], (h = {
                src: a
            }).label = a[this.options.xkey], this.options.parseTime ? (h.x = M.parseDate(h.label), this.options.dateFormat ? h.label = this.options.dateFormat(h.x) : "number" == typeof h.label && (h.label = new Date(h.label).toString())) : (h.x = r, this.options.xLabelFormat && (h.label = this.options.xLabelFormat(h))), p = 0, h.y = function() {
                var t, i, e, o;
                for (e = this.options.ykeys, o = [], n = t = 0, i = e.length; t < i; n = ++t) d = e[n], "string" == typeof(g = a[d]) && (g = parseFloat(g)), null != g && "number" != typeof g && (g = null), null != g && (this.cumulative ? p += g : null != c ? (c = Math.max(g, c), f = Math.min(g, f)) : c = f = g), this.cumulative && null != p && (c = Math.max(p, c), f = Math.min(p, f)), o.push(g);
                return o
            }.call(this), e.push(h);
            return e
        }.call(this), this.options.parseTime && (this.data = this.data.sort(function(t, i) {
            return (t.x > i.x) - (i.x > t.x)
        })), this.xmin = this.data[0].x, this.xmax = this.data[this.data.length - 1].x, this.events = [], 0 < this.options.events.length && (this.events = this.options.parseTime ? function() {
            var t, i, e, o;
            for (o = [], t = 0, i = (e = this.options.events).length; t < i; t++) s = e[t], o.push(M.parseDate(s));
            return o
        }.call(this) : this.options.events, this.xmax = Math.max(this.xmax, Math.max.apply(Math, this.events)), this.xmin = Math.min(this.xmin, Math.min.apply(Math, this.events))), this.xmin === this.xmax && (--this.xmin, this.xmax += 1), this.ymin = this.yboundary("min", f), this.ymax = this.yboundary("max", c), this.ymin === this.ymax && (f && --this.ymin, this.ymax += 1), !0 !== (m = this.options.axes) && "both" !== m && "y" !== m && !0 !== this.options.grid || (this.options.ymax === this.gridDefaults.ymax && this.options.ymin === this.gridDefaults.ymin ? (this.grid = this.autoGridLines(this.ymin, this.ymax, this.options.numLines), this.ymin = Math.min(this.ymin, this.grid[0]), this.ymax = Math.max(this.ymax, this.grid[this.grid.length - 1])) : (l = (this.ymax - this.ymin) / (this.options.numLines - 1), this.grid = function() {
            var t, i, e;
            for (e = [], u = t = this.ymin, i = this.ymax; 0 < l ? t <= i : i <= t; u = t += l) e.push(u);
            return e
        }.call(this))), this.dirty = !0, t ? this.redraw() : void 0)
    }, b.prototype.yboundary = function(t, i) {
        var e, o;
        return "string" == typeof(e = this.options["y" + t]) ? "auto" === e.slice(0, 4) ? 5 < e.length ? (o = parseInt(e.slice(5), 10), null == i ? o : Math[t](i, o)) : null != i ? i : 0 : parseInt(e, 10) : e
    }, b.prototype.autoGridLines = function(t, i, e) {
        var o, s, n, r, h, a, l, p;
        return r = i - t, p = Math.floor(Math.log(r) / Math.log(10)), a = Math.pow(10, p), s = Math.floor(t / a) * a, o = Math.ceil(i / a) * a, h = (o - s) / (e - 1), 1 === a && 1 < h && Math.ceil(h) !== h && (h = Math.ceil(h), o = s + h * (e - 1)), s < 0 && 0 < o && (s = Math.floor(t / h) * h, o = Math.ceil(i / h) * h), h < 1 ? (n = Math.floor(Math.log(h) / Math.log(10)), function() {
            var t, i;
            for (i = [], l = t = s; 0 < h ? t <= o : o <= t; l = t += h) i.push(parseFloat(l.toFixed(1 - n)));
            return i
        }()) : function() {
            var t, i;
            for (i = [], l = t = s; 0 < h ? t <= o : o <= t; l = t += h) i.push(l);
            return i
        }()
    }, b.prototype._calc = function() {
        var t, s, i, o, e, n, r, h;
        return e = this.el.width(), i = this.el.height(), (this.elementWidth !== e || this.elementHeight !== i || this.dirty) && (this.elementWidth = e, this.elementHeight = i, this.dirty = !1, this.left = this.options.padding, this.right = this.elementWidth - this.options.padding, this.top = this.options.padding, this.bottom = this.elementHeight - this.options.padding, !0 !== (r = this.options.axes) && "both" !== r && "y" !== r || (n = function() {
            var t, i, e, o;
            for (o = [], t = 0, i = (e = this.grid).length; t < i; t++) s = e[t], o.push(this.measureText(this.yAxisFormat(s)).width);
            return o
        }.call(this), this.left += Math.max.apply(Math, n)), !0 !== (h = this.options.axes) && "both" !== h && "x" !== h || (t = function() {
            var t, i, e;
            for (e = [], o = t = 0, i = this.data.length; 0 <= i ? t < i : i < t; o = 0 <= i ? ++t : --t) e.push(this.measureText(this.data[o].text, -this.options.xLabelAngle).height);
            return e
        }.call(this), this.bottom -= Math.max.apply(Math, t)), this.width = Math.max(1, this.right - this.left), this.height = Math.max(1, this.bottom - this.top), this.dx = this.width / (this.xmax - this.xmin), this.dy = this.height / (this.ymax - this.ymin), this.calc) ? this.calc() : void 0
    }, b.prototype.transY = function(t) {
        return this.bottom - (t - this.ymin) * this.dy
    }, b.prototype.transX = function(t) {
        return 1 === this.data.length ? (this.left + this.right) / 2 : this.left + (t - this.xmin) * this.dx
    }, b.prototype.redraw = function() {
        return this.raphael.clear(), this._calc(), this.drawGrid(), this.drawGoals(), this.drawEvents(), this.draw ? this.draw() : void 0
    }, b.prototype.measureText = function(t, i) {
        var e, o;
        return null == i && (i = 0), e = (o = this.raphael.text(100, 100, t).attr("font-size", this.options.gridTextSize).attr("font-family", this.options.gridTextFamily).attr("font-weight", this.options.gridTextWeight).rotate(i)).getBBox(), o.remove(), e
    }, b.prototype.yAxisFormat = function(t) {
        return this.yLabelFormat(t)
    }, b.prototype.yLabelFormat = function(t) {
        return "function" == typeof this.options.yLabelFormat ? this.options.yLabelFormat(t) : "" + this.options.preUnits + M.commas(t) + this.options.postUnits
    }, b.prototype.drawGrid = function() {
        var t, i, e, o, s, n, r, h;
        if (!1 !== this.options.grid || !0 === (s = this.options.axes) || "both" === s || "y" === s) {
            for (h = [], e = 0, o = (n = this.grid).length; e < o; e++) t = n[e], i = this.transY(t), !0 !== (r = this.options.axes) && "both" !== r && "y" !== r || this.drawYAxisLabel(this.left - this.options.padding / 2, i, this.yAxisFormat(t)), this.options.grid ? h.push(this.drawGridLine("M" + this.left + "," + i + "H" + (this.left + this.width))) : h.push(void 0);
            return h
        }
    }, b.prototype.drawGoals = function() {
        var t, i, e, o, s, n, r;
        for (r = [], e = o = 0, s = (n = this.options.goals).length; o < s; e = ++o) i = n[e], t = this.options.goalLineColors[e % this.options.goalLineColors.length], r.push(this.drawGoal(i, t));
        return r
    }, b.prototype.drawEvents = function() {
        var t, i, e, o, s, n, r;
        for (r = [], e = o = 0, s = (n = this.events).length; o < s; e = ++o) i = n[e], t = this.options.eventLineColors[e % this.options.eventLineColors.length], r.push(this.drawEvent(i, t));
        return r
    }, b.prototype.drawGoal = function(t, i) {
        return this.raphael.path("M" + this.left + "," + this.transY(t) + "H" + this.right).attr("stroke", i).attr("stroke-width", this.options.goalStrokeWidth)
    }, b.prototype.drawEvent = function(t, i) {
        return this.raphael.path("M" + this.transX(t) + "," + this.bottom + "V" + this.top).attr("stroke", i).attr("stroke-width", this.options.eventStrokeWidth)
    }, b.prototype.drawYAxisLabel = function(t, i, e) {
        return this.raphael.text(t, i, e).attr("font-size", this.options.gridTextSize).attr("font-family", this.options.gridTextFamily).attr("font-weight", this.options.gridTextWeight).attr("fill", this.options.gridTextColor).attr("text-anchor", "end")
    }, b.prototype.drawGridLine = function(t) {
        return this.raphael.path(t).attr("stroke", this.options.gridLineColor).attr("stroke-width", this.options.gridStrokeWidth)
    }, b.prototype.startRange = function(t) {
        return this.hover.hide(), this.selectFrom = t, this.selectionRect.attr({
            x: t,
            width: 0
        }).show()
    }, b.prototype.endRange = function(t) {
        var i, e;
        return this.selectFrom ? (e = Math.min(this.selectFrom, t), i = Math.max(this.selectFrom, t), this.options.rangeSelect.call(this.el, {
            start: this.data[this.hitTest(e)].x,
            end: this.data[this.hitTest(i)].x
        }), this.selectFrom = null) : void 0
    }, b.prototype.resizeHandler = function() {
        return this.timeoutId = null, this.raphael.setSize(this.el.width(), this.el.height()), this.redraw()
    }, b), M.parseDate = function(t) {
        var i, e, o, s, n, r, h, a, l, p, u;
        return "number" == typeof t ? t : (e = t.match(/^(\d+) Q(\d)$/), s = t.match(/^(\d+)-(\d+)$/), n = t.match(/^(\d+)-(\d+)-(\d+)$/), h = t.match(/^(\d+) W(\d+)$/), a = t.match(/^(\d+)-(\d+)-(\d+)[ T](\d+):(\d+)(Z|([+-])(\d\d):?(\d\d))?$/), l = t.match(/^(\d+)-(\d+)-(\d+)[ T](\d+):(\d+):(\d+(\.\d+)?)(Z|([+-])(\d\d):?(\d\d))?$/), e ? new Date(parseInt(e[1], 10), 3 * parseInt(e[2], 10) - 1, 1).getTime() : s ? new Date(parseInt(s[1], 10), parseInt(s[2], 10) - 1, 1).getTime() : n ? new Date(parseInt(n[1], 10), parseInt(n[2], 10) - 1, parseInt(n[3], 10)).getTime() : h ? (4 !== (p = new Date(parseInt(h[1], 10), 0, 1)).getDay() && p.setMonth(0, 1 + (4 - p.getDay() + 7) % 7), p.getTime() + 6048e5 * parseInt(h[2], 10)) : a ? a[6] ? (r = 0, "Z" !== a[6] && (r = 60 * parseInt(a[8], 10) + parseInt(a[9], 10), "+" === a[7] && (r = 0 - r)), Date.UTC(parseInt(a[1], 10), parseInt(a[2], 10) - 1, parseInt(a[3], 10), parseInt(a[4], 10), parseInt(a[5], 10) + r)) : new Date(parseInt(a[1], 10), parseInt(a[2], 10) - 1, parseInt(a[3], 10), parseInt(a[4], 10), parseInt(a[5], 10)).getTime() : l ? (u = parseFloat(l[6]), i = Math.floor(u), o = Math.round(1e3 * (u - i)), l[8] ? (r = 0, "Z" !== l[8] && (r = 60 * parseInt(l[10], 10) + parseInt(l[11], 10), "+" === l[9] && (r = 0 - r)), Date.UTC(parseInt(l[1], 10), parseInt(l[2], 10) - 1, parseInt(l[3], 10), parseInt(l[4], 10), parseInt(l[5], 10) + r, i, o)) : new Date(parseInt(l[1], 10), parseInt(l[2], 10) - 1, parseInt(l[3], 10), parseInt(l[4], 10), parseInt(l[5], 10), i, o).getTime()) : new Date(parseInt(t, 10), 0, 1).getTime())
    }, M.Hover = (w.defaults = {
        class: "morris-hover morris-default-style"
    }, w.prototype.update = function(t, i, e) {
        return t ? (this.html(t), this.show(), this.moveTo(i, e)) : this.hide()
    }, w.prototype.html = function(t) {
        return this.el.html(t)
    }, w.prototype.moveTo = function(t, i) {
        var e, o, s, n, r, h;
        return r = this.options.parent.innerWidth(), n = this.options.parent.innerHeight(), o = this.el.outerWidth(), e = this.el.outerHeight(), s = Math.min(Math.max(0, t - o / 2), r - o), null != i ? (h = i - e - 10) < 0 && n < (h = i + 10) + e && (h = n / 2 - e / 2) : h = n / 2 - e / 2, this.el.css({
            left: s + "px",
            top: parseInt(h) + "px"
        })
    }, w.prototype.show = function() {
        return this.el.show()
    }, w.prototype.hide = function() {
        return this.el.hide()
    }, w), M.Line = (a = M.Grid, t(x, a), x.prototype.init = function() {
        return "always" !== this.options.hideHover ? (this.hover = new M.Hover({
            parent: this.el
        }), this.on("hovermove", this.onHoverMove), this.on("hoverout", this.onHoverOut), this.on("gridclick", this.onGridClick)) : void 0
    }, x.prototype.defaults = {
        lineWidth: 3,
        pointSize: 4,
        lineColors: ["#0b62a4", "#7A92A3", "#4da74d", "#afd8f8", "#edc240", "#cb4b4b", "#9440ed"],
        pointStrokeWidths: [1],
        pointStrokeColors: ["#ffffff"],
        pointFillColors: [],
        smooth: !0,
        xLabels: "auto",
        xLabelFormat: null,
        xLabelMargin: 24,
        hideHover: !1
    }, x.prototype.calc = function() {
        return this.calcPoints(), this.generatePaths()
    }, x.prototype.calcPoints = function() {
        var s, n, t, i, e, o;
        for (o = [], t = 0, i = (e = this.data).length; t < i; t++)(s = e[t])._x = this.transX(s.x), s._y = function() {
            var t, i, e, o;
            for (o = [], t = 0, i = (e = s.y).length; t < i; t++) null != (n = e[t]) ? o.push(this.transY(n)) : o.push(n);
            return o
        }.call(this), o.push(s._ymax = Math.min.apply(Math, [this.bottom].concat(function() {
            var t, i, e, o;
            for (o = [], t = 0, i = (e = s._y).length; t < i; t++) null != (n = e[t]) && o.push(n);
            return o
        }())));
        return o
    }, x.prototype.hitTest = function(t) {
        var i, e, o, s;
        if (0 === this.data.length) return null;
        for (i = e = 0, o = (s = this.data.slice(1)).length; e < o && !(t < (s[i]._x + this.data[i]._x) / 2); i = ++e);
        return i
    }, x.prototype.onGridClick = function(t, i) {
        var e;
        return e = this.hitTest(t), this.fire("click", e, this.data[e].src, t, i)
    }, x.prototype.onHoverMove = function(t) {
        var i;
        return i = this.hitTest(t), this.displayHoverForRow(i)
    }, x.prototype.onHoverOut = function() {
        return !1 !== this.options.hideHover ? this.displayHoverForRow(null) : void 0
    }, x.prototype.displayHoverForRow = function(t) {
        var i;
        return null != t ? ((i = this.hover).update.apply(i, this.hoverContentForRow(t)), this.hilight(t)) : (this.hover.hide(), this.hilight())
    }, x.prototype.hoverContentForRow = function(t) {
        var i, e, o, s, n, r, h;
        for (i = "<div class='morris-hover-row-label'>" + (o = this.data[t]).label + "</div>", e = n = 0, r = (h = o.y).length; n < r; e = ++n) s = h[e], i += "<div class='morris-hover-point' style='color: " + this.colorFor(o, e, "label") + "'>\n  " + this.options.labels[e] + ":\n  " + this.yLabelFormat(s) + "\n</div>";
        return "function" == typeof this.options.hoverCallback && (i = this.options.hoverCallback(t, this.options, i, o.src)), [i, o._x, o._ymax]
    }, x.prototype.generatePaths = function() {
        var s, n, r, h;
        return this.paths = function() {
            var t, i, e, o;
            for (o = [], n = t = 0, i = this.options.ykeys.length; 0 <= i ? t < i : i < t; n = 0 <= i ? ++t : --t) h = "boolean" == typeof this.options.smooth ? this.options.smooth : (e = this.options.ykeys[n], 0 <= c.call(this.options.smooth, e)), 1 < (s = function() {
                var t, i, e, o;
                for (o = [], t = 0, i = (e = this.data).length; t < i; t++) void 0 !== (r = e[t])._y[n] && o.push({
                    x: r._x,
                    y: r._y[n]
                });
                return o
            }.call(this)).length ? o.push(M.Line.createPath(s, h, this.bottom)) : o.push(null);
            return o
        }.call(this)
    }, x.prototype.draw = function() {
        var t;
        return !0 !== (t = this.options.axes) && "both" !== t && "x" !== t || this.drawXAxis(), this.drawSeries(), !1 === this.options.hideHover ? this.displayHoverForRow(this.data.length - 1) : void 0
    }, x.prototype.drawXAxis = function() {
        var t, i, e, h, a, s, l, o, n, r, p = this;
        for (l = this.bottom + this.options.padding / 2, h = a = null, t = function(t, i) {
                var e, o, s, n, r;
                return r = (e = p.drawXAxisLabel(p.transX(i), l, t)).getBBox(), e.transform("r" + -p.options.xLabelAngle), o = e.getBBox(), e.transform("t0," + o.height / 2 + "..."), 0 !== p.options.xLabelAngle && (n = -.5 * r.width * Math.cos(p.options.xLabelAngle * Math.PI / 180), e.transform("t" + n + ",0...")), o = e.getBBox(), (null == a || a >= o.x + o.width || null != h && h >= o.x) && 0 <= o.x && o.x + o.width < p.el.width() ? (0 !== p.options.xLabelAngle && (s = 1.25 * p.options.gridTextSize / Math.sin(p.options.xLabelAngle * Math.PI / 180), h = o.x - s), a = o.x - p.options.xLabelMargin) : e.remove()
            }, (e = this.options.parseTime ? 1 === this.data.length && "auto" === this.options.xLabels ? [
                [this.data[0].label, this.data[0].x]
            ] : M.labelSeries(this.xmin, this.xmax, this.width, this.options.xLabels, this.options.xLabelFormat) : function() {
                var t, i, e, o;
                for (o = [], t = 0, i = (e = this.data).length; t < i; t++) s = e[t], o.push([s.label, s.x]);
                return o
            }.call(this)).reverse(), r = [], o = 0, n = e.length; o < n; o++) i = e[o], r.push(t(i[0], i[1]));
        return r
    }, x.prototype.drawSeries = function() {
        var t, i, e, o, s, n;
        for (this.seriesPoints = [], t = i = o = this.options.ykeys.length - 1; o <= 0 ? i <= 0 : 0 <= i; t = o <= 0 ? ++i : --i) this._drawLineFor(t);
        for (n = [], t = e = s = this.options.ykeys.length - 1; s <= 0 ? e <= 0 : 0 <= e; t = s <= 0 ? ++e : --e) n.push(this._drawPointFor(t));
        return n
    }, x.prototype._drawPointFor = function(t) {
        var i, e, o, s, n, r;
        for (this.seriesPoints[t] = [], r = [], o = 0, s = (n = this.data).length; o < s; o++)(i = null) != (e = n[o])._y[t] && (i = this.drawLinePoint(e._x, e._y[t], this.colorFor(e, t, "point"), t)), r.push(this.seriesPoints[t].push(i));
        return r
    }, x.prototype._drawLineFor = function(t) {
        var i;
        return null !== (i = this.paths[t]) ? this.drawLinePath(i, this.colorFor(null, t, "line"), t) : void 0
    }, x.createPath = function(t, i, e) {
        var o, s, n, r, h, a, l, p, u, d;
        for (l = "", i && (n = M.Line.gradients(t)), p = {
                y: null
            }, r = u = 0, d = t.length; u < d; r = ++u) null != (o = t[r]).y && (null != p.y ? i ? (s = n[r], a = n[r - 1], h = (o.x - p.x) / 4, l += "C" + (p.x + h) + "," + Math.min(e, p.y + h * a) + "," + (o.x - h) + "," + Math.min(e, o.y - h * s) + "," + o.x + "," + o.y) : l += "L" + o.x + "," + o.y : i && null == n[r] || (l += "M" + o.x + "," + o.y)), p = o;
        return l
    }, x.gradients = function(t) {
        var i, e, o, s, n, r, h, a;
        for (e = function(t, i) {
                return (t.y - i.y) / (t.x - i.x)
            }, a = [], o = r = 0, h = t.length; r < h; o = ++r) null != (i = t[o]).y ? (s = t[o + 1] || {
            y: null
        }, null != (n = t[o - 1] || {
            y: null
        }).y && null != s.y ? a.push(e(n, s)) : null != n.y ? a.push(e(n, i)) : null != s.y ? a.push(e(i, s)) : a.push(null)) : a.push(null);
        return a
    }, x.prototype.hilight = function(t) {
        var i, e, o, s, n;
        if (null !== this.prevHilight && this.prevHilight !== t)
            for (i = e = 0, s = this.seriesPoints.length - 1; 0 <= s ? e <= s : s <= e; i = 0 <= s ? ++e : --e) this.seriesPoints[i][this.prevHilight] && this.seriesPoints[i][this.prevHilight].animate(this.pointShrinkSeries(i));
        if (null !== t && this.prevHilight !== t)
            for (i = o = 0, n = this.seriesPoints.length - 1; 0 <= n ? o <= n : n <= o; i = 0 <= n ? ++o : --o) this.seriesPoints[i][t] && this.seriesPoints[i][t].animate(this.pointGrowSeries(i));
        return this.prevHilight = t
    }, x.prototype.colorFor = function(t, i, e) {
        return "function" == typeof this.options.lineColors ? this.options.lineColors.call(this, t, i, e) : "point" === e && this.options.pointFillColors[i % this.options.pointFillColors.length] || this.options.lineColors[i % this.options.lineColors.length]
    }, x.prototype.drawXAxisLabel = function(t, i, e) {
        return this.raphael.text(t, i, e).attr("font-size", this.options.gridTextSize).attr("font-family", this.options.gridTextFamily).attr("font-weight", this.options.gridTextWeight).attr("fill", this.options.gridTextColor)
    }, x.prototype.drawLinePath = function(t, i, e) {
        return this.raphael.path(t).attr("stroke", i).attr("stroke-width", this.lineWidthForSeries(e))
    }, x.prototype.drawLinePoint = function(t, i, e, o) {
        return this.raphael.circle(t, i, this.pointSizeForSeries(o)).attr("fill", e).attr("stroke-width", this.pointStrokeWidthForSeries(o)).attr("stroke", this.pointStrokeColorForSeries(o))
    }, x.prototype.pointStrokeWidthForSeries = function(t) {
        return this.options.pointStrokeWidths[t % this.options.pointStrokeWidths.length]
    }, x.prototype.pointStrokeColorForSeries = function(t) {
        return this.options.pointStrokeColors[t % this.options.pointStrokeColors.length]
    }, x.prototype.lineWidthForSeries = function(t) {
        return this.options.lineWidth instanceof Array ? this.options.lineWidth[t % this.options.lineWidth.length] : this.options.lineWidth
    }, x.prototype.pointSizeForSeries = function(t) {
        return this.options.pointSize instanceof Array ? this.options.pointSize[t % this.options.pointSize.length] : this.options.pointSize
    }, x.prototype.pointGrowSeries = function(t) {
        return Raphael.animation({
            r: this.pointSizeForSeries(t) + 3
        }, 25, "linear")
    }, x.prototype.pointShrinkSeries = function(t) {
        return Raphael.animation({
            r: this.pointSizeForSeries(t)
        }, 25, "linear")
    }, x), M.labelSeries = function(t, i, e, o, s) {
        var n, r, h, a, l, p, u, d, c, f, g;
        if (h = 200 * (i - t) / e, r = new Date(t), void 0 === (u = M.LABEL_SPECS[o]))
            for (c = 0, f = (g = M.AUTO_LABEL_ORDER).length; c < f; c++)
                if (a = g[c], h >= (p = M.LABEL_SPECS[a]).span) {
                    u = p;
                    break
                }
        for (void 0 === u && (u = M.LABEL_SPECS.second), s && (u = m.extend({}, u, {
                fmt: s
            })), n = u.start(r), l = [];
            (d = n.getTime()) <= i;) t <= d && l.push([u.fmt(n), d]), u.incr(n);
        return l
    }, i = function(i) {
        return {
            span: 60 * i * 1e3,
            start: function(t) {
                return new Date(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours())
            },
            fmt: function(t) {
                return M.pad2(t.getHours()) + ":" + M.pad2(t.getMinutes())
            },
            incr: function(t) {
                return t.setUTCMinutes(t.getUTCMinutes() + i)
            }
        }
    }, e = function(i) {
        return {
            span: 1e3 * i,
            start: function(t) {
                return new Date(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes())
            },
            fmt: function(t) {
                return M.pad2(t.getHours()) + ":" + M.pad2(t.getMinutes()) + ":" + M.pad2(t.getSeconds())
            },
            incr: function(t) {
                return t.setUTCSeconds(t.getUTCSeconds() + i)
            }
        }
    }, M.LABEL_SPECS = {
        decade: {
            span: 1728e8,
            start: function(t) {
                return new Date(t.getFullYear() - t.getFullYear() % 10, 0, 1)
            },
            fmt: function(t) {
                return "" + t.getFullYear()
            },
            incr: function(t) {
                return t.setFullYear(t.getFullYear() + 10)
            }
        },
        year: {
            span: 1728e7,
            start: function(t) {
                return new Date(t.getFullYear(), 0, 1)
            },
            fmt: function(t) {
                return "" + t.getFullYear()
            },
            incr: function(t) {
                return t.setFullYear(t.getFullYear() + 1)
            }
        },
        month: {
            span: 24192e5,
            start: function(t) {
                return new Date(t.getFullYear(), t.getMonth(), 1)
            },
            fmt: function(t) {
                return t.getFullYear() + "-" + M.pad2(t.getMonth() + 1)
            },
            incr: function(t) {
                return t.setMonth(t.getMonth() + 1)
            }
        },
        week: {
            span: 6048e5,
            start: function(t) {
                return new Date(t.getFullYear(), t.getMonth(), t.getDate())
            },
            fmt: function(t) {
                return t.getFullYear() + "-" + M.pad2(t.getMonth() + 1) + "-" + M.pad2(t.getDate())
            },
            incr: function(t) {
                return t.setDate(t.getDate() + 7)
            }
        },
        day: {
            span: 864e5,
            start: function(t) {
                return new Date(t.getFullYear(), t.getMonth(), t.getDate())
            },
            fmt: function(t) {
                return t.getFullYear() + "-" + M.pad2(t.getMonth() + 1) + "-" + M.pad2(t.getDate())
            },
            incr: function(t) {
                return t.setDate(t.getDate() + 1)
            }
        },
        hour: i(60),
        "30min": i(30),
        "15min": i(15),
        "10min": i(10),
        "5min": i(5),
        minute: i(1),
        "30sec": e(30),
        "15sec": e(15),
        "10sec": e(10),
        "5sec": e(5),
        second: e(1)
    }, M.AUTO_LABEL_ORDER = ["decade", "year", "month", "week", "day", "hour", "30min", "15min", "10min", "5min", "minute", "30sec", "15sec", "10sec", "5sec", "second"], M.Area = (r = M.Line, t(v, r), h = {
        fillOpacity: "auto",
        behaveLikeLine: !1
    }, v.prototype.calcPoints = function() {
        var s, n, r, t, i, e, o;
        for (o = [], t = 0, i = (e = this.data).length; t < i; t++)(s = e[t])._x = this.transX(s.x), n = 0, s._y = function() {
            var t, i, e, o;
            for (o = [], t = 0, i = (e = s.y).length; t < i; t++) r = e[t], this.options.behaveLikeLine ? o.push(this.transY(r)) : (n += r || 0, o.push(this.transY(n)));
            return o
        }.call(this), o.push(s._ymax = Math.max.apply(Math, s._y));
        return o
    }, v.prototype.drawSeries = function() {
        var t, i, e, o, s, n, r, h;
        for (this.seriesPoints = [], h = [], e = 0, o = (i = this.options.behaveLikeLine ? function() {
                n = [];
                for (var t = 0, i = this.options.ykeys.length - 1; 0 <= i ? t <= i : i <= t; 0 <= i ? t++ : t--) n.push(t);
                return n
            }.apply(this) : function() {
                r = [];
                for (var t = s = this.options.ykeys.length - 1; s <= 0 ? t <= 0 : 0 <= t; s <= 0 ? t++ : t--) r.push(t);
                return r
            }.apply(this)).length; e < o; e++) t = i[e], this._drawFillFor(t), this._drawLineFor(t), h.push(this._drawPointFor(t));
        return h
    }, v.prototype._drawFillFor = function(t) {
        var i;
        return null !== (i = this.paths[t]) ? (i += "L" + this.transX(this.xmax) + "," + this.bottom + "L" + this.transX(this.xmin) + "," + this.bottom + "Z", this.drawFilledPath(i, this.fillForSeries(t))) : void 0
    }, v.prototype.fillForSeries = function(t) {
        var i;
        return i = Raphael.rgb2hsl(this.colorFor(this.data[t], t, "line")), Raphael.hsl(i.h, this.options.behaveLikeLine ? .9 * i.s : .75 * i.s, Math.min(.98, this.options.behaveLikeLine ? 1.2 * i.l : 1.25 * i.l))
    }, v.prototype.drawFilledPath = function(t, i) {
        return this.raphael.path(t).attr("fill", i).attr("fill-opacity", this.options.fillOpacity).attr("stroke", "none")
    }, v), M.Bar = (n = M.Grid, t(y, n), y.prototype.init = function() {
        return this.cumulative = this.options.stacked, "always" !== this.options.hideHover ? (this.hover = new M.Hover({
            parent: this.el
        }), this.on("hovermove", this.onHoverMove), this.on("hoverout", this.onHoverOut), this.on("gridclick", this.onGridClick)) : void 0
    }, y.prototype.defaults = {
        barSizeRatio: .75,
        barGap: 3,
        barColors: ["#0b62a4", "#7a92a3", "#4da74d", "#afd8f8", "#edc240", "#cb4b4b", "#9440ed"],
        barOpacity: 1,
        barRadius: [0, 0, 0, 0],
        xLabelMargin: 50
    }, y.prototype.calc = function() {
        var t;
        return this.calcBars(), !1 === this.options.hideHover ? (t = this.hover).update.apply(t, this.hoverContentForRow(this.data.length - 1)) : void 0
    }, y.prototype.calcBars = function() {
        var t, s, n, i, e, o, r;
        for (r = [], t = i = 0, e = (o = this.data).length; i < e; t = ++i)(s = o[t])._x = this.left + this.width * (t + .5) / this.data.length, r.push(s._y = function() {
            var t, i, e, o;
            for (o = [], t = 0, i = (e = s.y).length; t < i; t++) null != (n = e[t]) ? o.push(this.transY(n)) : o.push(null);
            return o
        }.call(this));
        return r
    }, y.prototype.draw = function() {
        var t;
        return !0 !== (t = this.options.axes) && "both" !== t && "x" !== t || this.drawXAxis(), this.drawSeries()
    }, y.prototype.drawXAxis = function() {
        var t, i, e, o, s, n, r, h, a, l, p, u, d;
        for (l = this.bottom + (this.options.xAxisLabelTopPadding || this.options.padding / 2), n = r = null, d = [], t = p = 0, u = this.data.length; 0 <= u ? p < u : u < p; t = 0 <= u ? ++p : --p) h = this.data[this.data.length - 1 - t], a = (i = this.drawXAxisLabel(h._x, l, h.label)).getBBox(), i.transform("r" + -this.options.xLabelAngle), e = i.getBBox(), i.transform("t0," + e.height / 2 + "..."), 0 !== this.options.xLabelAngle && (s = -.5 * a.width * Math.cos(this.options.xLabelAngle * Math.PI / 180), i.transform("t" + s + ",0...")), (null == r || r >= e.x + e.width || null != n && n >= e.x) && 0 <= e.x && e.x + e.width < this.el.width() ? (0 !== this.options.xLabelAngle && (o = 1.25 * this.options.gridTextSize / Math.sin(this.options.xLabelAngle * Math.PI / 180), n = e.x - o), d.push(r = e.x - this.options.xLabelMargin)) : d.push(i.remove());
        return d
    }, y.prototype.drawSeries = function() {
        var s, n, r, h, a, l, p, t, u, d, c, i, f, g, m;
        return r = this.width / this.options.data.length, t = this.options.stacked ? 1 : this.options.ykeys.length, s = (r * this.options.barSizeRatio - this.options.barGap * (t - 1)) / t, this.options.barSize && (s = Math.min(s, this.options.barSize)), i = r - s * t - this.options.barGap * (t - 1), p = i / 2, m = this.ymin <= 0 && 0 <= this.ymax ? this.transY(0) : null, this.bars = function() {
            var t, i, e, o;
            for (e = this.data, o = [], h = t = 0, i = e.length; t < i; h = ++t) u = e[h], a = 0, o.push(function() {
                var t, i, e, o;
                for (e = u._y, o = [], d = t = 0, i = e.length; t < i; d = ++t) null !== (g = e[d]) ? (n = m ? (f = Math.min(g, m), Math.max(g, m)) : (f = g, this.bottom), l = this.left + h * r + p, this.options.stacked || (l += d * (s + this.options.barGap)), c = n - f, this.options.verticalGridCondition && this.options.verticalGridCondition(u.x) && this.drawBar(this.left + h * r, this.top, r, Math.abs(this.top - this.bottom), this.options.verticalGridColor, this.options.verticalGridOpacity, this.options.barRadius), this.options.stacked && (f -= a), this.drawBar(l, f, s, c, this.colorFor(u, d, "bar"), this.options.barOpacity, this.options.barRadius), o.push(a += c)) : o.push(null);
                return o
            }.call(this));
            return o
        }.call(this)
    }, y.prototype.colorFor = function(t, i, e) {
        var o, s;
        return "function" == typeof this.options.barColors ? (o = {
            x: t.x,
            y: t.y[i],
            label: t.label
        }, s = {
            index: i,
            key: this.options.ykeys[i],
            label: this.options.labels[i]
        }, this.options.barColors.call(this, o, s, e)) : this.options.barColors[i % this.options.barColors.length]
    }, y.prototype.hitTest = function(t) {
        return 0 === this.data.length ? null : (t = Math.max(Math.min(t, this.right), this.left), Math.min(this.data.length - 1, Math.floor((t - this.left) / (this.width / this.data.length))))
    }, y.prototype.onGridClick = function(t, i) {
        var e;
        return e = this.hitTest(t), this.fire("click", e, this.data[e].src, t, i)
    }, y.prototype.onHoverMove = function(t) {
        var i, e;
        return i = this.hitTest(t), (e = this.hover).update.apply(e, this.hoverContentForRow(i))
    }, y.prototype.onHoverOut = function() {
        return !1 !== this.options.hideHover ? this.hover.hide() : void 0
    }, y.prototype.hoverContentForRow = function(t) {
        var i, e, o, s, n, r, h;
        for (i = "<div class='morris-hover-row-label'>" + (o = this.data[t]).label + "</div>", e = n = 0, r = (h = o.y).length; n < r; e = ++n) s = h[e], i += "<div class='morris-hover-point' style='color: " + this.colorFor(o, e, "label") + "'>\n  " + this.options.labels[e] + ":\n  " + this.yLabelFormat(s) + "\n</div>";
        return "function" == typeof this.options.hoverCallback && (i = this.options.hoverCallback(t, this.options, i, o.src)), [i, this.left + (t + .5) * this.width / this.data.length]
    }, y.prototype.drawXAxisLabel = function(t, i, e) {
        return this.raphael.text(t, i, e).attr("font-size", this.options.gridTextSize).attr("font-family", this.options.gridTextFamily).attr("font-weight", this.options.gridTextWeight).attr("fill", this.options.gridTextColor)
    }, y.prototype.drawBar = function(t, i, e, o, s, n, r) {
        var h;
        return (0 === (h = Math.max.apply(Math, r)) || o < h ? this.raphael.rect(t, i, e, o) : this.raphael.path(this.roundedRect(t, i, e, o, r))).attr("fill", s).attr("fill-opacity", n).attr("stroke", "none")
    }, y.prototype.roundedRect = function(t, i, e, o, s) {
        return null == s && (s = [0, 0, 0, 0]), ["M", t, s[0] + i, "Q", t, i, t + s[0], i, "L", t + e - s[1], i, "Q", t + e, i, t + e, i + s[1], "L", t + e, i + o - s[2], "Q", t + e, i + o, t + e - s[2], i + o, "L", t + s[3], i + o, "Q", t, i + o, t, i + o - s[3], "Z"]
    }, y), M.Donut = (s = M.EventEmitter, t(g, s), g.prototype.defaults = {
        colors: ["#0B62A4", "#3980B5", "#679DC6", "#95BBD7", "#B0CCE1", "#095791", "#095085", "#083E67", "#052C48", "#042135"],
        backgroundColor: "#FFFFFF",
        labelColor: "#000000",
        formatter: M.commas,
        resize: !1
    }, g.prototype.redraw = function() {
        var t, i, e, o, s, n, r, h, a, l, p, u, d, c, f, g, m, y, v, x, w, b;
        for (this.raphael.clear(), i = this.el.width() / 2, e = this.el.height() / 2, u = (Math.min(i, e) - 10) / 3, d = p = 0, g = (v = this.values).length; d < g; d++) p += v[d];
        for (h = 5 / (2 * u), t = 1.9999 * Math.PI - h * this.data.length, s = n = 0, this.segments = [], o = c = 0, m = (x = this.values).length; c < m; o = ++c) a = n + h + x[o] / p * t, (l = new M.DonutSegment(i, e, 2 * u, u, n, a, this.data[o].color || this.options.colors[s % this.options.colors.length], this.options.backgroundColor, s, this.raphael)).render(), this.segments.push(l), l.on("hover", this.select), l.on("click", this.click), n = a, s += 1;
        for (this.text1 = this.drawEmptyDonutLabel(i, e - 10, this.options.labelColor, 15, 800), this.text2 = this.drawEmptyDonutLabel(i, 10 + e, this.options.labelColor, 14), r = Math.max.apply(Math, this.values), b = [], f = s = 0, y = (w = this.values).length; f < y; f++) {
            if (w[f] === r) {
                this.select(s);
                break
            }
            b.push(s += 1)
        }
        return b
    }, g.prototype.setData = function(t) {
        var s;
        return this.data = t, this.values = function() {
            var t, i, e, o;
            for (o = [], t = 0, i = (e = this.data).length; t < i; t++) s = e[t], o.push(parseFloat(s.value));
            return o
        }.call(this), this.redraw()
    }, g.prototype.click = function(t) {
        return this.fire("click", t, this.data[t])
    }, g.prototype.select = function(t) {
        var i, e, o, s;
        for (e = 0, o = (s = this.segments).length; e < o; e++) s[e].deselect();
        return this.segments[t].select(), i = this.data[t], this.setLabels(i.label, this.options.formatter(i.value, i))
    }, g.prototype.setLabels = function(t, i) {
        var e, o, s, n, r, h, a, l;
        return n = 1.8 * (e = 2 * (Math.min(this.el.width() / 2, this.el.height() / 2) - 10) / 3), s = e / 2, o = e / 3, this.text1.attr({
            text: t,
            transform: ""
        }), r = this.text1.getBBox(), h = Math.min(n / r.width, s / r.height), this.text1.attr({
            transform: "S" + h + "," + h + "," + (r.x + r.width / 2) + "," + (r.y + r.height)
        }), this.text2.attr({
            text: i,
            transform: ""
        }), a = this.text2.getBBox(), l = Math.min(n / a.width, o / a.height), this.text2.attr({
            transform: "S" + l + "," + l + "," + (a.x + a.width / 2) + "," + a.y
        })
    }, g.prototype.drawEmptyDonutLabel = function(t, i, e, o, s) {
        var n;
        return n = this.raphael.text(t, i, "").attr("font-size", o).attr("fill", e), null != s && n.attr("font-weight", s), n
    }, g.prototype.resizeHandler = function() {
        return this.timeoutId = null, this.raphael.setSize(this.el.width(), this.el.height()), this.redraw()
    }, g), M.DonutSegment = (o = M.EventEmitter, t(f, o), f.prototype.calcArcPoints = function(t) {
        return [this.cx + t * this.sin_p0, this.cy + t * this.cos_p0, this.cx + t * this.sin_p1, this.cy + t * this.cos_p1]
    }, f.prototype.calcSegment = function(t, i) {
        var e, o, s, n, r, h, a, l, p, u;
        return e = (p = this.calcArcPoints(t))[0], s = p[1], o = p[2], n = p[3], r = (u = this.calcArcPoints(i))[0], a = u[1], h = u[2], l = u[3], "M" + e + "," + s + "A" + t + "," + t + ",0," + this.is_long + ",0," + o + "," + n + "L" + h + "," + l + "A" + i + "," + i + ",0," + this.is_long + ",1," + r + "," + a + "Z"
    }, f.prototype.calcArc = function(t) {
        var i, e, o, s, n;
        return i = (n = this.calcArcPoints(t))[0], o = n[1], e = n[2], s = n[3], "M" + i + "," + o + "A" + t + "," + t + ",0," + this.is_long + ",0," + e + "," + s
    }, f.prototype.render = function() {
        var t = this;
        return this.arc = this.drawDonutArc(this.hilight, this.color), this.seg = this.drawDonutSegment(this.path, this.color, this.backgroundColor, function() {
            return t.fire("hover", t.index)
        }, function() {
            return t.fire("click", t.index)
        })
    }, f.prototype.drawDonutArc = function(t, i) {
        return this.raphael.path(t).attr({
            stroke: i,
            "stroke-width": 2,
            opacity: 0
        })
    }, f.prototype.drawDonutSegment = function(t, i, e, o, s) {
        return this.raphael.path(t).attr({
            fill: i,
            stroke: e,
            "stroke-width": 3
        }).hover(o).click(s)
    }, f.prototype.select = function() {
        return this.selected ? void 0 : (this.seg.animate({
            path: this.selectedPath
        }, 150, "<>"), this.arc.animate({
            opacity: 1
        }, 150, "<>"), this.selected = !0)
    }, f.prototype.deselect = function() {
        return this.selected ? (this.seg.animate({
            path: this.path
        }, 150, "<>"), this.arc.animate({
            opacity: 0
        }, 150, "<>"), this.selected = !1) : void 0
    }, f)
}).call(this);